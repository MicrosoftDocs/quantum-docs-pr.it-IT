---
title: Introduzione alle tecniche di sviluppo Quantum | Microsoft Docs
description: Introduzione alle tecniche di sviluppo Quantum
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 9c266fe16b8e2a265d91a99f8574a6acfcf03160
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/26/2019
ms.locfileid: "73183251"
---
# <a name="what-is-q"></a><span data-ttu-id="95b22-103">Che cos'è Q#?</span><span class="sxs-lookup"><span data-stu-id="95b22-103">What is Q#?</span></span> #

<span data-ttu-id="95b22-104">Q # è un linguaggio di programmazione scalabile, multiparadigma e specifico di dominio per quantum computing.</span><span class="sxs-lookup"><span data-stu-id="95b22-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="95b22-105">Q # è un linguaggio di programmazione Quantum in quanto può essere usato per descrivere il modo in cui vengono eseguite le istruzioni sui computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="95b22-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="95b22-106">I computer che possono essere assegnati da simulatori a hardware Quantum effettivo.</span><span class="sxs-lookup"><span data-stu-id="95b22-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="95b22-107">Q # è scalabile: può essere usato per scrivere semplici programmi dimostrativi, ad esempio Teleport, eseguiti in pochi qubits, ma supporta anche la scrittura di programmi di grandi dimensioni, ad esempio simulazioni di molecole complesse che richiedono computer di grandi dimensioni con milioni di qubits.</span><span class="sxs-lookup"><span data-stu-id="95b22-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="95b22-108">Anche se i computer fisici di grandi dimensioni sono ancora in futuro, Q # consente a un programmatore di programmare ora algoritmi quantistici complessi.</span><span class="sxs-lookup"><span data-stu-id="95b22-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="95b22-109">Q # supporta varie attività, come il debug, la profilatura, la stima delle risorse e alcune simulazioni per scopi specifici in modo scalabile.</span><span class="sxs-lookup"><span data-stu-id="95b22-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="95b22-110">Dal punto di vista tecnico, un programma quantum può essere considerato come un particolare set di funzioni classiche che, quando chiamato, generano circuiti Quantum come effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="95b22-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="95b22-111">Una conseguenza importante di tale visualizzazione è che un programma scritto in Q # non modella direttamente qubits, ma descrive in che modo un computer di controllo classico interagisce con tali qubits.</span><span class="sxs-lookup"><span data-stu-id="95b22-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="95b22-112">Per impostazione predefinita, Q # non definisce gli Stati del quantum o altre proprietà di meccanica quantistica direttamente, bensì indirettamente tramite l'azione delle varie subroutine definite nel linguaggio.</span><span class="sxs-lookup"><span data-stu-id="95b22-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="95b22-113">Si consideri, ad esempio, lo stato $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ descritti nella Guida ai [concetti relativi al quantum computing](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="95b22-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="95b22-114">Per preparare questo stato in Q #, si usano i fatti che i qubits vengono inizializzati nello stato $ \ket{0}$ e che $ \ket{+} = H\ket{0}$, dove $H $ è la trasformazione Hadamard:</span><span class="sxs-lookup"><span data-stu-id="95b22-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="95b22-115">Q # trasformazioni degli Stati Quantum</span><span class="sxs-lookup"><span data-stu-id="95b22-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="95b22-116">In particolare, nella scrittura del programma precedente, non è stato fatto riferimento in modo esplicito allo stato entro Q #, ma è stato invece descritto come lo stato è stato *trasformato* dal programma.</span><span class="sxs-lookup"><span data-stu-id="95b22-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="95b22-117">In modo analogo a come un programma shader grafico accumula una descrizione delle trasformazioni in ogni vertice, un programma Quantum in Q # accumula le trasformazioni negli Stati Quantum.</span><span class="sxs-lookup"><span data-stu-id="95b22-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="95b22-118">Ciò consente di essere completamente agnostico sullo stato del *Quantum anche in ogni computer di destinazione* , che potrebbe avere interpretazioni diverse a seconda del computer.</span><span class="sxs-lookup"><span data-stu-id="95b22-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="95b22-119">Dal punto di vista di un programma Q #, un qubit è un riferimento completamente opaco alla struttura interna di un computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="95b22-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="95b22-120">Un programma Q # non è in grado di analizzare lo stato di un qubit, la relativa rappresentazione in un computer di destinazione o anche se si tratta dello stesso qubit di qualsiasi altro qubit disponibile per il programma.</span><span class="sxs-lookup"><span data-stu-id="95b22-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="95b22-121">Un programma può invece chiamare operazioni come `Measure` per apprendere le informazioni da un qubit e chiamare operazioni quali `X` e `H` per agire sullo stato di un qubit.</span><span class="sxs-lookup"><span data-stu-id="95b22-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="95b22-122">Queste operazioni non hanno una definizione intrinseca all'interno del linguaggio e sono rese concrete solo dal computer di destinazione usato per eseguire un particolare programma Q #.</span><span class="sxs-lookup"><span data-stu-id="95b22-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="95b22-123">Un programma Q # ricombina queste operazioni in base a quanto definito da un computer di destinazione per creare nuove operazioni di livello superiore per esprimere il calcolo quantistico.</span><span class="sxs-lookup"><span data-stu-id="95b22-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="95b22-124">In questo modo, Q # rende più semplice esprimere gli algoritmi Quantum e ibrido della logica sottostanti, oltre a essere generali rispetto alla struttura di un computer o di un simulatore di destinazione.</span><span class="sxs-lookup"><span data-stu-id="95b22-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="95b22-125">Operazioni e funzioni Q #</span><span class="sxs-lookup"><span data-stu-id="95b22-125">Q# operations and functions</span></span>

<span data-ttu-id="95b22-126">In concreto, un programma Q # è costituito da una o più *operazioni*, una o più *funzioni*e tipi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="95b22-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="95b22-127">Le operazioni vengono usate per descrivere le trasformazioni dello stato di un computer Quantum e costituiscono il blocco predefinito più semplice dei programmi Q #.</span><span class="sxs-lookup"><span data-stu-id="95b22-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="95b22-128">Ogni operazione definita in Q # può quindi chiamare un numero qualsiasi di altre operazioni, incluse le operazioni *intrinseche* predefinite implementate da un computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="95b22-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="95b22-129">Quando viene compilata, ogni operazione viene rappresentata come tipo di classe .NET che può essere fornita ai computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="95b22-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="95b22-130">Diversamente dalle operazioni, le funzioni vengono usate per descrivere il comportamento puramente classico e non hanno effetti oltre al calcolo dei valori di output classici.</span><span class="sxs-lookup"><span data-stu-id="95b22-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="95b22-131">Q # è un linguaggio fortemente tipizzato ed è dotato di un set di tipi primitivi incorporati, nonché del supporto per i tipi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="95b22-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="95b22-132">Nella parte restante di questa guida, si vedrà come usare concetti e costrutti di linguaggio diversi per semplificare la definizione di programmi Quantum complessi mediante i blocchi predefiniti di base di operazioni, funzioni e tipi.</span><span class="sxs-lookup"><span data-stu-id="95b22-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="95b22-133">Struttura dei file di origine Q #</span><span class="sxs-lookup"><span data-stu-id="95b22-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="95b22-134">Almeno un file di origine Q # è costituito da una *dichiarazione dello spazio dei nomi*, che specifica uno spazio dei nomi .NET che conterrà le definizioni nel file di origine.</span><span class="sxs-lookup"><span data-stu-id="95b22-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="95b22-135">Le definizioni di altri file di origine e librerie Q # possono essere incluse usando l'istruzione `open`.</span><span class="sxs-lookup"><span data-stu-id="95b22-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="95b22-136">Ad esempio, la maggior parte delle operazioni che definiscono i controlli di base sono definite nello spazio dei nomi <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="95b22-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="95b22-137">Per renderlo disponibile al codice, è sufficiente `open` lo spazio dei nomi nella parte superiore di ogni file:</span><span class="sxs-lookup"><span data-stu-id="95b22-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="95b22-138">All'interno di uno spazio dei nomi, ogni file di origine Q # può definire qualsiasi combinazione di *operazioni*, *funzioni*e *tipi definiti dall'utente*.</span><span class="sxs-lookup"><span data-stu-id="95b22-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="95b22-139">Nella parte restante di questa sezione verranno descritti ciascuno a sua volta e verranno forniti esempi di come possono essere usati in pratica per creare programmi Quantum utili.</span><span class="sxs-lookup"><span data-stu-id="95b22-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
