---
title: 'Q # librerie standard-caratterizzazione | Microsoft Docs'
description: 'Q # librerie standard-caratterizzazione'
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: d77085aa8aa83c18858056bab1858d990efdb36e
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/29/2019
ms.locfileid: "73185563"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="1147d-103">Caratterizzazione e statistiche del quantum</span><span class="sxs-lookup"><span data-stu-id="1147d-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="1147d-104">È fondamentale essere in grado di caratterizzare gli effetti delle operazioni per sviluppare algoritmi quantistici utili.</span><span class="sxs-lookup"><span data-stu-id="1147d-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="1147d-105">Si tratta di una sfida complessa perché ogni misura di un sistema quantico restituisce al massimo una quantità di informazioni.</span><span class="sxs-lookup"><span data-stu-id="1147d-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="1147d-106">Per apprendere un autovalore, lasciare da solo uno stato quantico, i risultati di molte misurazioni devono essere Uniti in modo che l'utente possa raccogliere i molti bit di informazioni necessari per rappresentare questi concetti.</span><span class="sxs-lookup"><span data-stu-id="1147d-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="1147d-107">Gli Stati Quantum sono soprattutto vexing perché il [teorema di non clonazione](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) indica che non esiste alcun modo per apprendere uno stato quantico arbitrario da una singola copia dello stato, perché questa operazione consente di creare copie dello stato.</span><span class="sxs-lookup"><span data-stu-id="1147d-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="1147d-108">Questa offuscamento dello stato del quantum dall'utente si riflette nel fatto che Q # non espone o addirittura *definisce lo stato* dei programmi quantistici.</span><span class="sxs-lookup"><span data-stu-id="1147d-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="1147d-109">In questo modo si avvicina la caratterizzazione quantistica considerando le operazioni e gli Stati come Black-Box; Questo approccio condivide molto in comune con la pratica sperimentale di caratterizzazione quantistica, verifica e convalida (QCVV).</span><span class="sxs-lookup"><span data-stu-id="1147d-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="1147d-110">La caratterizzazione è diversa da molte altre librerie illustrate in precedenza.</span><span class="sxs-lookup"><span data-stu-id="1147d-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="1147d-111">L'obiettivo è quello di ottenere meno informazioni classiche sul sistema, anziché eseguire una trasformazione unitaria su un vettore di stato.</span><span class="sxs-lookup"><span data-stu-id="1147d-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="1147d-112">Queste librerie devono quindi combinare l'elaborazione di informazioni sia classica che quantistica.</span><span class="sxs-lookup"><span data-stu-id="1147d-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="1147d-113">Valutazione della fase iterativa</span><span class="sxs-lookup"><span data-stu-id="1147d-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="1147d-114">La visualizzazione della programmazione quantistica in termini di caratterizzazione quantistica suggerisce un'alternativa utile alla stima della fase quantistica.</span><span class="sxs-lookup"><span data-stu-id="1147d-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="1147d-115">Ovvero, anziché preparare un $n registro $-qubit in modo che contenga una rappresentazione binaria della fase come la stima della fase quantistica, è possibile visualizzare la stima della fase come processo mediante il quale un agente *classico* apprende le proprietà di un sistema Quantum tramite misurazioni.</span><span class="sxs-lookup"><span data-stu-id="1147d-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="1147d-116">Si procede come nel caso di Quantum usando il contraccolpo della fase per trasformare le applicazioni di un'operazione di colore nero in rotazioni in base a un angolo sconosciuto, ma misurerà il qubit ancilla che viene ruotato a ogni passaggio immediatamente dopo la rotazione.</span><span class="sxs-lookup"><span data-stu-id="1147d-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="1147d-117">Questo ha il vantaggio di richiedere un solo qubit aggiuntivo per eseguire il contraccolpo della fase descritto nel caso quantum, in quanto viene quindi appresa la fase dai risultati della misurazione in ogni fase in modo iterativo.</span><span class="sxs-lookup"><span data-stu-id="1147d-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="1147d-118">Ogni metodo proposto di seguito utilizza una strategia diversa per la progettazione di esperimenti e metodi di elaborazione dei dati diversi per apprendere la fase.</span><span class="sxs-lookup"><span data-stu-id="1147d-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="1147d-119">Ognuno di essi ha un vantaggio univoco, dal momento che presenta limiti di errore rigorosi, alle capacità di incorporare informazioni precedenti, tollerare errori o eseguire in memoria computer limitted classici.</span><span class="sxs-lookup"><span data-stu-id="1147d-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="1147d-120">In una descrizione della stima della fase iterativa, si considererà un $U unitario $ dato come operazione Black Box.</span><span class="sxs-lookup"><span data-stu-id="1147d-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="1147d-121">Come descritto nella sezione relativa ai Oracle in [strutture di dati](xref:microsoft.quantum.libraries.data-structures), i modelli Canon Q # tali operazioni vengono eseguite dal <xref:microsoft.quantum.oracles.discreteoracle> tipo definito dall'utente, definito dal tipo di tupla `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span><span class="sxs-lookup"><span data-stu-id="1147d-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="1147d-122">In concreto, se `U : DiscreteOracle`, `U(m)` implementa $U ^ m $ per `m : Int`.</span><span class="sxs-lookup"><span data-stu-id="1147d-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="1147d-123">Con questa definizione, ogni passaggio della valutazione della fase iterativa procede preparando un qubit auxillary nello stato $ \ket{+} $ insieme allo stato iniziale $ \ket{\Phi} $ che si presuppone sia un [autovettore](xref:microsoft.quantum.concepts.matrix-advanced) di $U (m) $, ad esempio $U (m) \ket{\Phi} = e ^ {im\phi} \ket{\Phi} $.</span><span class="sxs-lookup"><span data-stu-id="1147d-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxillary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="1147d-124">Viene quindi usata un'applicazione controllata di `U(m)` che prepara lo stato $ \left (R\_1 (m \Phi) \ket{+} \right) \ket{\Phi} $.</span><span class="sxs-lookup"><span data-stu-id="1147d-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="1147d-125">Come nel caso del quantum, l'effetto di un'applicazione controllata del `U(m)` Oracle è esattamente lo stesso dell'applicazione $R _1 $ per la fase sconosciuta in $ \ket{+} $, in modo da poter descrivere gli effetti di $U $ in questo modo più semplice.</span><span class="sxs-lookup"><span data-stu-id="1147d-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="1147d-126">Facoltativamente, l'algoritmo ruota quindi il qubit del controllo applicando $R _1 (-m\theta) $ per ottenere uno stato $ \ket{\psi} = \left (R\_1 (m [\Phi-\theta]) \ket{+} \right) \ket{\Phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="1147d-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="1147d-127">Il qubit auxillary usato come controllo per `U(m)` viene quindi misurato nella base $X $ per ottenere una singola `Result`classica.</span><span class="sxs-lookup"><span data-stu-id="1147d-127">The auxillary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="1147d-128">A questo punto, la ricostruzione della fase dalla `Result` valori ottenuti tramite la stima della fase iterativa è un problema di inferenza statistico classico.</span><span class="sxs-lookup"><span data-stu-id="1147d-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="1147d-129">La ricerca del valore di $m $ che ingrandisce le informazioni acquisite, dato un metodo di inferenza fisso, rappresenta semplicemente un problema nelle statistiche.</span><span class="sxs-lookup"><span data-stu-id="1147d-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="1147d-130">Questa operazione viene enfatizzata brevemente descrivendo brevemente la stima della fase iterativa a un livello teorico nel formalismo per la stima dei parametri Bayes prima di procedere con la descrizione degli algoritmi statistici forniti nel canone Q # per la risoluzione di questa inferenza classica problema.</span><span class="sxs-lookup"><span data-stu-id="1147d-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="1147d-131">Valutazione della fase iterativa senza autostati</span><span class="sxs-lookup"><span data-stu-id="1147d-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="1147d-132">Se viene fornito uno stato di input che non è un autostato, ovvero se $U (m) \ket{\Phi\_j} = e ^ {im\phi\_j} $, il processo di valutazione della fase non deterministicamente guida lo stato del quantum verso un singolo autostato di energia.</span><span class="sxs-lookup"><span data-stu-id="1147d-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="1147d-133">Il autostato in cui si converge a è il autostato che con maggiore probabilità produrrà il `Result`osservato.</span><span class="sxs-lookup"><span data-stu-id="1147d-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="1147d-134">In particolare, un singolo passaggio di PE esegue la trasformazione non unitaria seguente in uno stato \begin{align} \sum_j \sqrt{\Pr (\Phi\_j)} \ket{\Phi\_j} \mapsto \sum\_j\frac {\ sqrt {\ PR (\Phi\_j)} \sqrt{\Pr (\text{Result} | \ Phi\_j)} \ket{\Phi\_j}} {\sqrt{\Pr (\Phi\_j) \sum\_j \Pr (\text{Result} | \Phi\_j)}}.</span><span class="sxs-lookup"><span data-stu-id="1147d-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="1147d-135">\end{align} poiché questo processo viene iterato su più valori `Result`, autostati che non hanno valori massimi di $ \prod_k\Pr (\text{Result}\_k | \Phi\_j) $ verranno eliminati in modo esponenziale.</span><span class="sxs-lookup"><span data-stu-id="1147d-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="1147d-136">Di conseguenza, il processo di inferenza tenderà a convergere agli Stati con un singolo autovalore se gli esperimenti vengono scelti correttamente.</span><span class="sxs-lookup"><span data-stu-id="1147d-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="1147d-137">Bayes ' teorema suggerisce ulteriormente che lo stato risultante dalla stima della fase viene scritto nel formato \begin{align} \frac{\sqrt{\Pr (\Phi\_j)} \sqrt{\Pr (\text{Result} | \Phi\_j)} \ket{\Phi\_j}} {\sqrt{\Pr (\Phi\_j) \sum\_j \Pr (\text{Result} | \Phi\_j)}} = \sum_j \sqrt{\Pr (\Phi\_j | \text{Result})} \ket{\Phi\_j}.</span><span class="sxs-lookup"><span data-stu-id="1147d-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="1147d-138">\end{align} here $ \Pr (\Phi\_j | \text{Result}) $ può essere interpretted come probabilità che venga attribuita a ogni ipotesi relativa al autostati dato:</span><span class="sxs-lookup"><span data-stu-id="1147d-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="1147d-139">conoscere lo stato del Quantum prima della misurazione,</span><span class="sxs-lookup"><span data-stu-id="1147d-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="1147d-140">conoscenza della autostati di $U $ e,</span><span class="sxs-lookup"><span data-stu-id="1147d-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="1147d-141">conoscenza degli autovalori di $U $.</span><span class="sxs-lookup"><span data-stu-id="1147d-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="1147d-142">L'apprendimento di questi tre elementi è spesso esponenzialmente difficile in un computer classico.</span><span class="sxs-lookup"><span data-stu-id="1147d-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="1147d-143">L'utilità della valutazione della fase si verifica, a un certo punto, dal fatto che può eseguire tale attività di apprendimento quantico senza conoscerne alcuno.</span><span class="sxs-lookup"><span data-stu-id="1147d-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="1147d-144">La stima della fase per questo motivo viene visualizzata all'interno di una serie di algoritmi Quantum che forniscono velocità esponenziali.</span><span class="sxs-lookup"><span data-stu-id="1147d-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="1147d-145">Valutazione della fase Bayes</span><span class="sxs-lookup"><span data-stu-id="1147d-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="1147d-146">Per ulteriori informazioni sulla stima della fase bayesiano, vedere l'esempio [**PhaseEstimation**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation) .</span><span class="sxs-lookup"><span data-stu-id="1147d-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation) sample.</span></span>

<span data-ttu-id="1147d-147">Il concetto di stima della fase Bayes è semplice.</span><span class="sxs-lookup"><span data-stu-id="1147d-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="1147d-148">Si raccolgono le statistiche di misurazione dal protocollo di stima della fase e quindi si elaborano i risultati usando l'inferenza Bayes e si fornisce una stima del parametro.</span><span class="sxs-lookup"><span data-stu-id="1147d-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="1147d-149">Questa elaborazione consente di stimare il valore di autovalore e l'incertezza nella stima.</span><span class="sxs-lookup"><span data-stu-id="1147d-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="1147d-150">Consente inoltre di eseguire esperimenti adattivi e di utilizzare le informazioni precedenti.</span><span class="sxs-lookup"><span data-stu-id="1147d-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="1147d-151">Lo svantaggio principale dei metodi è che è richiesto dal punto di vista del calcolo.</span><span class="sxs-lookup"><span data-stu-id="1147d-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="1147d-152">Per comprendere il funzionamento del processo di inferenza Bayes, prendere in considerazione il caso di elaborazione di un singolo risultato `Zero`.</span><span class="sxs-lookup"><span data-stu-id="1147d-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="1147d-153">Si noti che $X = \ket{+} \bra{+}-\ket{-}\bra{-}$, in modo che $ \ket{+} $ sia l'unico autostato positivo di $X $ corrispondente a `Zero`.</span><span class="sxs-lookup"><span data-stu-id="1147d-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="1147d-154">La probabilità di osservare `Zero` per una [misura`PauliX`](xref:microsoft.quantum.concepts.pauli) sul primo qubit dato uno stato di input $ \ket{\psi}\ket{\Phi} $ è quindi \begin{Equation} \Pr (\texttt{zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="1147d-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="1147d-155">\end{Equation} nel caso della stima della fase iterativa, è necessario che $ \ket{\psi} = R_1 (m [\Phi-\theta]) \ket{+} $, in modo che \begin{align} \Pr (\texttt{Zero} | \Phi; m, \theta) & = \left | \braket{+ | R_1 (m [\Phi-\theta]) | +} \right | ^ 2 \\\\ & = \left | \frac12 \left (\bra{0} + \bra{1} \right) \left (\ket{0} + e ^ {i m [\Phi-\theta]} \ket{1} \right) \right | ^ 2 \\\\ & = \left | \frac{1 + e ^ {i m [\Phi-\theta]}}{2} \right | ^ 2 \\\\ & = \cos ^ 2 (m [\Phi-\theta]/2) \tag{★} \label{EQ: fase-est-probabilità}.</span><span class="sxs-lookup"><span data-stu-id="1147d-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="1147d-156">\end{align}, ovvero la stima della fase iterativa consiste nell'apprendimento della frequenza di oscillazione di una funzione sinusoidale, data la possibilità di capovolgere un Coin con una distorsione fornita da tale sinusoide.</span><span class="sxs-lookup"><span data-stu-id="1147d-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="1147d-157">Seguendo la terminologia classica tradizionale, viene chiamato $ \eqref{EQ: fase-est-probabilità} $ la *funzione di probabilità* per la stima della fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="1147d-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="1147d-158">Osservando un `Result` dalla funzione di probabilità di stima della fase iterativa, è possibile usare la regola Bayes per prescrivere ciò che si dovrebbe ritenere che la fase stia seguendo tale osservazione.</span><span class="sxs-lookup"><span data-stu-id="1147d-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="1147d-159">In concreto, \begin{Equation} \Pr (\Phi | d) = \frac{\Pr (d | \Phi) \Pr (\Phi)} {\int \Pr (d | \Phi) \Pr (\Phi) {\mathrm d} \Phi} \Pr (\Phi), \end{Equation} dove $d \In \\{\texttt{Zero}, \texttt{One}\\} $ è un `Result`e dove $ \Pr (\Phi) $ descrive le opinioni precedenti su $ \Phi $.</span><span class="sxs-lookup"><span data-stu-id="1147d-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="1147d-160">In questo modo, la natura iterativa della stima della fase iterativa è esplicita, in quanto la distribuzione posteriore $ \Pr (\Phi | d) $ descrive le convinzioni immediatamente precedente l'osservazione del `Result`successivo.</span><span class="sxs-lookup"><span data-stu-id="1147d-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceeding our observation of the next `Result`.</span></span>

<span data-ttu-id="1147d-161">In qualsiasi momento durante questa procedura, è possibile segnalare la fase $ \hat{\Phi} $ dedotta dal controller classico come \begin{Equation} \hat{\Phi} \mathrel{: =} \expect [\Phi | \Text{data}] = \int \Phi \Pr (\Phi | \Text{Data}) {\mathrm d} \Phi, \end{Equation} dove $ \ il testo {data} $ sta per l'intero record di tutti i valori `Result` ottenuti.</span><span class="sxs-lookup"><span data-stu-id="1147d-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="1147d-162">L'inferenza bayesiano esatta è in pratica ingestibile.</span><span class="sxs-lookup"><span data-stu-id="1147d-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="1147d-163">Per scoprire che si vuole conoscere una variabile $n $ bit $x $.</span><span class="sxs-lookup"><span data-stu-id="1147d-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="1147d-164">La distribuzione precedente $ \Pr (x) $ supporta più di $2 ^ n $ ipotetici valori di $x $.</span><span class="sxs-lookup"><span data-stu-id="1147d-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="1147d-165">Ciò significa che se è necessaria una stima accurata della $x $ then la stima della fase Bayes potrebbe richiedere tempi di elaborazione e memoria proibitivi.</span><span class="sxs-lookup"><span data-stu-id="1147d-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="1147d-166">Sebbene per alcune applicazioni, ad esempio la simulazione quantistica, l'accuratezza limitted richiesta non Ostia ad altri metodi, ad esempio l'algoritmo Shor, non è in grado di utilizzare l'inferenza bayesiano esatta entro il suo passaggio di stima della fase.</span><span class="sxs-lookup"><span data-stu-id="1147d-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="1147d-167">Per questo motivo, vengono fornite anche le implementazioni per i metodi Bayes approssimativi, ad esempio la [stima della fase di Walk casuale (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) e anche approcci non Bayes come la [stima della fase affidabile](xref:microsoft.quantum.characterization.robustphaseestimation).</span><span class="sxs-lookup"><span data-stu-id="1147d-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="1147d-168">Stima della fase affidabile</span><span class="sxs-lookup"><span data-stu-id="1147d-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="1147d-169">Un massimo di una ricostruzione Bayes a *posteriori* di una fase stimata dai risultati della misurazione è esponenzialmente difficile nel peggiore dei casi.</span><span class="sxs-lookup"><span data-stu-id="1147d-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="1147d-170">In questo modo, la maggior parte degli algoritmi di stima della fase più pratici sacrificano una certa qualità nella ricostruzione, in cambio di una quantità di post-elaborazione classica che invece si ridimensiona in base al numero di misurazioni effettuate.</span><span class="sxs-lookup"><span data-stu-id="1147d-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="1147d-171">Uno di questi esempi con una fase di post-elaborazione classica efficiente è l' [algoritmo di stima della fase affidabile](https://arxiv.org/abs/1502.02677), con la firma e gli input citati in precedenza.</span><span class="sxs-lookup"><span data-stu-id="1147d-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="1147d-172">Si presuppone che le caselle nere di input $U $ siano inserite come `DiscreteOracle` tipo ed è quindi possibile eseguire query solo su potenze integer del controllo-$U $.</span><span class="sxs-lookup"><span data-stu-id="1147d-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="1147d-173">Se lo stato di input nel registro `Qubit[]` è autostato $U \ket{\psi} = e ^ {i\phi} \ KET {\ psi} $, l'algoritmo di stima della fase affidabile restituisce una stima $ \hat{\Phi}\In [-\Pi, \Pi) $ di $ \Phi $ come `Double`.</span><span class="sxs-lookup"><span data-stu-id="1147d-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="1147d-174">La funzionalità più importante della valutazione delle fasi affidabili, che è condivisa con la maggior parte delle altre varianti utili, consiste nel fatto che la qualità della ricostruzione di $ \hat{\Phi} $ è in un certo senso Heisenberg-Limited.</span><span class="sxs-lookup"><span data-stu-id="1147d-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="1147d-175">Ciò significa che se la deviazione di $ \hat{\Phi} $ dal valore true è $ \sigma $, $ \sigma $ esegue il ridimensionamento inversamente proporzionale al numero totale di query $Q $ effettuate a controllata-$U $, ad esempio $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="1147d-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="1147d-176">La definizione della deviazione varia ora tra algoritmi di stima diversi.</span><span class="sxs-lookup"><span data-stu-id="1147d-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="1147d-177">In alcuni casi, potrebbe significare che con almeno $ \mathcal{O} (1) $ probabilità, l'errore di stima $ | \hat{\Phi}-\Phi |\_\circ\le \sigma $ su una misura circolare $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="1147d-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="1147d-178">Per una stima della fase affidabile, la deviazione è esattamente la varianza $ \sigma ^ 2 = \mathbb{E}\_\hat{\Phi} [(\mod\_{2 \ PI} (\hat{\Phi}-\Phi + \Pi)-\Pi) ^ 2] $ Se si esegue il wrapping di fasi periodiche in un singolo intervallo finito $ (-\Pi, \Pi] $.</span><span class="sxs-lookup"><span data-stu-id="1147d-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="1147d-179">Più precisamente, la deviazione standard nella stima della fase affidabile soddisfa le disuguaglianze $ $ \begin{align} 2,0 \Pi/Q \Le \sigma \Le 2 \ PI/2 ^ {n} \Le 10.7 \ PI/Q, \end{align} $ $ dove viene raggiunto il limite inferiore nel limite di asintoticamente grande $Q $ e il valore superiore il limite è garantito anche per piccole dimensioni di esempio.</span><span class="sxs-lookup"><span data-stu-id="1147d-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="1147d-180">Si noti che $n $ selezionato dall'input `bitsPrecision`, che definisce in modo implicito $Q $.</span><span class="sxs-lookup"><span data-stu-id="1147d-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="1147d-181">Altri dettagli pertinenti includono, ad esempio, il sovraccarico di spazio ridotto di soli $1 $ ancilla qubit o che la procedura non è adattiva, ovvero la sequenza richiesta di esperimenti Quantum è indipendente dai risultati della misurazione intermedia.</span><span class="sxs-lookup"><span data-stu-id="1147d-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="1147d-182">In questo ed esempi imminenti in cui la scelta dell'algoritmo di stima della fase è importante, è necessario fare riferimento alla documentazione, ad esempio @"microsoft.quantum.canon.robustphaseestimation" e le pubblicazioni a cui si fa riferimento, per ottenere ulteriori informazioni e per la loro implementazione.</span><span class="sxs-lookup"><span data-stu-id="1147d-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.canon.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="1147d-183">Sono disponibili molti esempi in cui viene usata la stima della fase affidabile.</span><span class="sxs-lookup"><span data-stu-id="1147d-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="1147d-184">Per la stima della fase nell'estrazione dell'energia dello stato di base di un sistema fisico diverso, vedere l'esempio di [ **simulazione H2** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine), l' [esempio **SimpleIsing** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing)e l'esempio di [ **modello Hubbard** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/HubbardSimulation).</span><span class="sxs-lookup"><span data-stu-id="1147d-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine), the [**SimpleIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing), and the [**Hubbard model** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/HubbardSimulation).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="1147d-185">Oracle continui</span><span class="sxs-lookup"><span data-stu-id="1147d-185">Continuous Oracles</span></span> ###

<span data-ttu-id="1147d-186">È anche possibile generalizzare dal modello Oracle usato in precedenza per consentire Oracle a tempo continuo, modellati in base al tipo di canone <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="1147d-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="1147d-187">Si consideri che invece di un singolo operatore unitario $U $, abbiamo una famiglia di operatori unitari $U (t) $ per $t \in \mathbb{R} $, in modo che $U (t) U/s $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="1147d-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="1147d-188">Si tratta di una dichiarazione più vulnerabile rispetto al caso discreto, dal momento che è possibile creare un <xref:microsoft.quantum.oracles.discreteoracle> limitando $t = m\,\delta t $ per alcuni \delta $ $ corretti.</span><span class="sxs-lookup"><span data-stu-id="1147d-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="1147d-189">Per [teorema di Stone](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ per un operatore $H $, dove $ \exp $ è la matrice esponenziale, come descritto in [matrici avanzate](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="1147d-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="1147d-190">Un autostato $ \ket{\Phi} $ di $H $ tale che $H \ket{\Phi} = \Phi \ket{\Phi} $ è quindi anche un autostato di $U (t) $ per tutti $t $, \begin{Equation} U (t) \ket{\Phi} = e ^ {i \Phi t} \ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="1147d-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="1147d-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="1147d-191">\end{equation}</span></span>

<span data-ttu-id="1147d-192">È possibile applicare esattamente la stessa analisi descritta per la [stima della fase Bayes](#bayesian-phase-estimation) e la funzione probabilità è esattamente la stessa per questo modello Oracle più generale: $ $ \Pr (\texttt{zero} | \Phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\Phi-\theta]} @no__ t_1_ \right).</span><span class="sxs-lookup"><span data-stu-id="1147d-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="1147d-193">$ $ Inoltre, se $U $ è una simulazione di un generatore dinamico, come nel caso della [simulazione hamiltoniana](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), viene interpretato $ \Phi $ come energia.</span><span class="sxs-lookup"><span data-stu-id="1147d-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="1147d-194">Quindi, l'uso della stima della fase con le query continue consente di apprendere lo [spettro di energia simulato di molecole](https://arxiv.org/abs/quant-ph/0604193), [materiali](https://arxiv.org/abs/1510.03859) o [teorie sui campi](https://arxiv.org/abs/1111.3633v2) senza compromettere la scelta degli esperimenti richiedendo $t $ come valore integer.</span><span class="sxs-lookup"><span data-stu-id="1147d-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="1147d-195">Valutazione della fase di Walk casuale</span><span class="sxs-lookup"><span data-stu-id="1147d-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="1147d-196">Q # fornisce un'approssimazione utile della valutazione della fase Bayes progettata per l'uso vicino a dispositivi Quantum che operano condizionando un percorso casuale sul record di dati ottenuto dalla stima della fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="1147d-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="1147d-197">Questo metodo è sia adattivo che completamente deterministico, consentendo una scalabilità quasi ottimale degli errori nella fase stimata $ \hat{\Phi} $ con sovraccarico di memoria molto bassa.</span><span class="sxs-lookup"><span data-stu-id="1147d-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="1147d-198">Il protocollo usa un metodo di inferenza Bayes approssimativo che presuppone che la distribuzione precedente sia gaussiana.</span><span class="sxs-lookup"><span data-stu-id="1147d-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="1147d-199">Questo presupposto di Gauss consente di usare una formula analitica per l'esperimento che riduce al minimo la varianza posteriore.</span><span class="sxs-lookup"><span data-stu-id="1147d-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="1147d-200">L'algoritmo, quindi, in base al risultato di tale esperimento, sposta la stima di $ \Phi $ Left o right in base a una quantità predeterminata e compatta la varianza in base a una quantità predeterminata.</span><span class="sxs-lookup"><span data-stu-id="1147d-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="1147d-201">Questa media e varianza forniscono tutte le informazioni necessarie per specificare un gaussiana prima di $ \Phi $ per l'esperimento successivo.</span><span class="sxs-lookup"><span data-stu-id="1147d-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="1147d-202">Gli errori di misurazione imprevisti o il risultato reale che si trova sulla parte finale del precedente, possono causare un errore di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="1147d-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="1147d-203">Il ripristino da un errore viene effettuato eseguendo esperimenti per verificare se la media e la deviazione standard correnti sono appropriate per il sistema.</span><span class="sxs-lookup"><span data-stu-id="1147d-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="1147d-204">In caso contrario, l'algoritmo esegue un passaggio inverso del percorso e il processo continua.</span><span class="sxs-lookup"><span data-stu-id="1147d-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="1147d-205">La possibilità di eseguire un'istruzione all'indietro consente inoltre all'algoritmo di apprendere anche se la deviazione standard iniziale precedente è inapropriately Small.</span><span class="sxs-lookup"><span data-stu-id="1147d-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="1147d-206">Algoritmi di stima della fase chiamante</span><span class="sxs-lookup"><span data-stu-id="1147d-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="1147d-207">Ogni operazione di stima della fase fornita con il canone Q # accetta un set di input diverso parametrizzazione la qualità richiesta dalla stima finale $ \hat{\Phi} $.</span><span class="sxs-lookup"><span data-stu-id="1147d-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="1147d-208">Questi diversi input, tuttavia, condividono tutti diversi input in comune, in modo che l'applicazione parziale sui parametri di qualità produce una firma comune.</span><span class="sxs-lookup"><span data-stu-id="1147d-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="1147d-209">Ad esempio, l'operazione <xref:microsoft.quantum.characterization.robustphaseestimation> descritta nella sezione successiva presenta la firma seguente:</span><span class="sxs-lookup"><span data-stu-id="1147d-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="1147d-210">Il `bitsPrecision` input è univoco per `RobustPhaseEstimation`, mentre `oracle` e `eigenstate` sono in comune.</span><span class="sxs-lookup"><span data-stu-id="1147d-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="1147d-211">Quindi, come illustrato in **H2Sample**, un'operazione può accettare un algoritmo di stima della fase iterativo con un input del modulo `(DiscreteOracle, Qubit[]) => Unit` per consentire a un utente di specificare algoritmi di stima della fase arbitraria:</span><span class="sxs-lookup"><span data-stu-id="1147d-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int, 
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) 
: Double
```

<span data-ttu-id="1147d-212">Questi algoritmi di stima della fase miriade sono ottimizzati per diverse proprietà e parametri di input, che devono essere riconosciuti per eseguire la scelta migliore per l'applicazione di destinazione.</span><span class="sxs-lookup"><span data-stu-id="1147d-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="1147d-213">Ad esempio, alcuni algoritmi di stima della fase sono adattivi, vale a dire che i passaggi futuri sono controllati in modo classico dai risultati della misurazione dei passaggi precedenti.</span><span class="sxs-lookup"><span data-stu-id="1147d-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="1147d-214">Alcuni richiedono la possibilità di exponentiate il proprio Oracle unitario nero in base a poteri reali arbitrari, mentre altri richiedono solo le potenze di tipo Integer ma sono in grado di risolvere solo un modulo di stima della fase $2 \ PI $.</span><span class="sxs-lookup"><span data-stu-id="1147d-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="1147d-215">Alcuni richiedono molti qubits di Auxillary e altri ne richiedono solo uno.</span><span class="sxs-lookup"><span data-stu-id="1147d-215">Some require many auxillary qubits, and other require only one.</span></span>

<span data-ttu-id="1147d-216">Analogamente, l'uso della valutazione della fase di Walk casuale procede in modo molto simile a quello di altri algoritmi forniti con la Canon:</span><span class="sxs-lookup"><span data-stu-id="1147d-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ExampleOracle(eigenphase : Double, time : Double, register : Qubit[]) : Unit
is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation BayesianPhaseEstimationCanonSample(eigenphase : Double) : Double {

    let oracle = ContinuousOracle(ExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
