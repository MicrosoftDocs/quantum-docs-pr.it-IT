---
title: Guida alla revisione della lingua e alla migrazione di QDK 0,3
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: 5131c1c9159c0e6d6ae2daa051bb95f69785f056
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/29/2019
ms.locfileid: "73184951"
---
# <a name="introduction"></a>Introduzione #

Siamo lieti di introdurre l'aggiornamento più recente per Quantum Development Kit.  Questa pagina offre una panoramica delle nuove funzionalità del linguaggio Q # e illustra come [eseguire la migrazione](#Migration) di programmi q # esistenti alla nuova sintassi.  Per la descrizione completa del linguaggio Q #, vedere [qui](xref:microsoft.quantum.language.intro)la documentazione completa.


# <a name="whats-new"></a>Novità #

L'aggiornamento 0,3 include una gamma di nuove funzionalità di linguaggio e di editor.

## <a name="overview-of-features"></a>Panoramica delle funzionalità

- Integrazione avanzata degli strumenti di sviluppo per Visual Studio e Visual Studio Code, tra cui:
    - Compilazione e feedback in tempo reale sulla digitazione (*noto* anche come sottolineatura ondulata).
    - Informazioni sul passaggio del mouse, inclusi riepiloghi della documentazione e firme di tipi.
    - Supporto per Vai a definizione.
    - Navigazione semplificata per le dichiarazioni di spazio dei nomi, operazione, funzione e tipo.
    - Messaggi di diagnostica migliorati.
- Miglioramenti del linguaggio
    - Singole inizializzazioni di qubit e tuple all'interno di using e borrowing
    - Decostruzione di Tuple per tutte le assegnazioni
    - Iterazione su matrici
    - Espressioni condizionali
    - Abbreviazione di specializzazione predefinita per le operazioni
    - Costruttori di tipi generati automaticamente
    - Modificatori di espressione


## <a name="editor-features"></a>Funzionalità dell'editor

Quantum Development Kit include ora un server di linguaggio per Q #, nonché le integrazioni client per Visual Studio e Visual Studio Code.
Questo consente un nuovo set di funzionalità IntelliSense insieme a commenti e suggerimenti Live sulla digitazione sotto forma di sottolineature ondulate di errori e avvisi.
In particolare, vai a definizione è ora supportato e vengono visualizzate le informazioni relative al passaggio del mouse contenenti informazioni sul tipo, oltre alle informazioni contenute nella documentazione dei commenti. Inoltre, le informazioni sui simboli relativi a spazi dei nomi, operazioni, funzioni e tipi definiti sono disponibili e consentono di passare rapidamente alle dichiarazioni.    
Questo aggiornamento consente di migliorare notevolmente i messaggi di diagnostica in generale, con facilità di spostamento e intervalli precisi per la diagnostica e dettagli aggiuntivi nelle informazioni visualizzate al passaggio del mouse. 

Per questa versione 0,3, il server di linguaggio incluso in Quantum Development Kit non supporta più aree di lavoro.
Per utilizzare un progetto in VS Code, aprire la cartella radice contenente il progetto stesso e tutti i progetti a cui si fa riferimento.
Per lavorare con una soluzione in Visual Studio, tutti i progetti contenuti nella soluzione devono trovarsi nella stessa cartella della soluzione o in una delle relative sottocartelle.

## <a name="language-features"></a>Funzionalità del linguaggio

In termini di funzionalità del linguaggio, questo aggiornamento unifica il trattamento di una gamma di modelli di linguaggio.
I costruttori di tipo, ad esempio, vengono generati per ogni tipo definito dall'utente e possono essere applicati parzialmente in modo analogo a qualsiasi altra funzione.
Un altro esempio è la decostruzione di tuple, che ora è completamente supportata all'interno di tutte le assegnazioni. Sono incluse non solo le istruzioni set-, mutable-e set-, ma anche la variabile di iterazione nei cicli for, nonché l'uso di-e le allocazioni in prestito. Inoltre, le decostruzioni parziali sono appena supportate con l'aggiornamento 0,3; i caratteri di sottolineatura nelle decostruzioni indicano parti del valore che devono essere ignorate. 

Il codice seguente illustra alcune delle nuove funzionalità:
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
L'ultima istruzione set usa un nuovo operatore ternario introdotto con l'aggiornamento 0,3 per supportare le espressioni condizionali.
Un'espressione condizionale è un'espressione nel formato `condition ? caseTrue | caseFalse`.
Come si può notare dall'esempio precedente, è ora supportata anche l'iterazione sulle matrici.

Le allocazioni all'interno di `using` e `borrowing` sono appena possibili per singole qubits, matrici qubit e Tuple nidificate:
```qsharp
    using (q = Qubit()) {
        // q contains a single qubit
    }

    borrowing ((cs, q) = (Qubit[3], Qubit())) {
        // cs contains an array of three qubits, and q contains a single qubit
    }
```

Vengono introdotte due nuove direttive del generatore di specializzazione `invert` e `distribute` oltre ai `auto` vengono introdotte per aumentare il controllo sul modo in cui vengono generate le specializzazioni di Function.
Una dichiarazione esplicita della specializzazione `body` predefinita all'interno delle operazioni non è più obbligatoria.
Analogamente alle funzioni, le istruzioni possono essere aggiunte direttamente alla dichiarazione dell'operazione se nessuna altra specializzazione viene dichiarata all'interno dell'operazione.
Uno script di migrazione è incluso nella versione per facilitare la migrazione del codice esistente e sfruttare i vantaggi delle nuove funzionalità del linguaggio. vedere la [sezione relativa allo script di migrazione](#MigrationScript).

Una modifica importante per il modo in cui vengono trattati i tipi definiti dall'utente viene fornita con l'aggiornamento 0,3. Mentre le versioni precedenti consideravano i tipi definiti dall'utente come sottotipi del relativo tipo sottostante, questo non è più il caso in futuro (vedere anche la [sezione relativa alle modifiche di rilievo](#BreakingChanges)).  
Come parte di questa modifica, vengono introdotti i modificatori di espressioni che possono essere applicati a determinate espressioni. Le espressioni "atomiche" a cui è possibile applicare i modificatori sono gli identificatori, le espressioni di elementi della matrice e le tuple grado-1.
I modificatori si associano più rigorosi rispetto a qualsiasi altro combinatore di espressioni e in particolare più rigoroso del combinatore delle espressioni di chiamata `(` `)`. 
`Adjoint`, `Controlled`e un nuovo operatore suffisso "Unwrap" `!` vengono trattati come modificatori di espressione. Il trattamento `Adjoint` e `Controlled` come modificatori di espressione Elimina la necessità di parentesi per diversi casi. Le espressioni seguenti, ad esempio, sono valide in futuro per `Op`, un'operazione unitaria, `opArr` una matrice di operazioni unitarie e `arg` un argomento appropriato: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
Lo script di migrazione eliminerà la maggior parte delle parentesi superflue e approfitterà di tutte le nuove funzionalità. Tuttavia, tenere presente che lo script non interpreta il codice e non tiene conto della diversa interpretazione del `Controlled` functore in rari casi (pertinente solo in combinazione con applicazioni parziali).

Il nuovo modificatore `!` esegue il cast di un tipo definito dall'utente al relativo tipo sottostante. Questo cast è stato considerato un cast nelle versioni precedenti ed è stato eseguito automaticamente. Con la nuova interpretazione dei tipi definiti dall'utente, questo non è più il caso ed è necessario rendere esplicito il cast.    
Nell'esempio seguente viene illustrato come utilizzare il nuovo modificatore: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], q : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (q);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (q);
            Adjoint unitaries[0]! (q);
        }
    }
```
Come si può notare dall'esempio, `!` associa più restrittivi dei modificatori di prefisso, ad esempio `Controlled` e `Adjoint`.

#<a name="BreakingChanges"></a>Modifiche di rilievo #

L'aggiornamento 0,3 include un nuovo compilatore e contiene alcune modifiche di rilievo.
Per facilitare l'aggiornamento del codice esistente, il compilatore fornisce anche un'opzione di formattazione che compila codice valido o non valido ed emette codice Q # formattato in base alla compilazione compilata.
Tutte le modifiche alla sintassi verranno elaborate automaticamente dallo strumento fornito. Tuttavia, le modifiche apportate al modo in cui il codice valido viene interpretato (modifiche semantiche) potrebbe essere necessario eseguire manualmente. 

Oltre alle modifiche elencate di seguito, il criterio `__*__` dove * è qualsiasi sequenza di caratteri diversi da spazi vuoti è riservata per uso interno e non può essere usata come nome di simbolo.  

## <a name="syntax-changes"></a>Modifiche della sintassi ##

- A partire dalla versione 0,3, gli elementi di matrice non sono più separati da punti e virgola, ma sono invece separati da virgole.
- Un punto e virgola d'altra parte è necessario dopo una direttiva di generazione automatica per le dichiarazioni di specializzazione.
- Le condizioni nelle clausole if-, elif-e until-devono essere incapsulate tra parentesi. 

Per tutte le altre modifiche della sintassi, il compilatore genererà semplicemente un avviso se viene utilizzata la sintassi precedente.     
Un esempio di tale modifica è la tupla dei simboli nelle specializzazioni definite dall'utente. Nelle versioni precedenti, una dichiarazione di specializzazione controllata o controllata ha specificato un solo argomento Symbol, a partire da 0,3 è consigliabile fornire tale tupla di simboli per tutte le specializzazioni con `...` indicante che il compilatore Se necessario, eseguire la migrazione dei simboli dalla dichiarazione chiamabile. 

## <a name="semantic-changes"></a>Modifiche semantiche ##

Il problema più significativo per la versione 0,3 è il modo in cui i tipi definiti dall'utente sono integrati nel sistema di tipi. Nelle versioni precedenti i tipi definiti dall'utente erano considerati un sottotipo del tipo sottostante. Con questa versione e in futuro non è più così. I tipi definiti dall'utente sono ora considerati di tipo distinto e non esiste alcun cast automatico tra un tipo definito dall'utente e il tipo sottostante. Tutti i cast devono essere resi espliciti tramite un operatore "Unwrap" `!`ed è necessario un cast in particolare per accedere al contenuto di un oggetto di tipo definito dall'utente.  

Le modifiche al sistema di tipi includono inoltre il comportamento di varianza delle matrici e il trattamento di oggetti con parametri di tipo. A partire da 0,3, le matrici modificabili e non modificabili sono invariabili. Inoltre, gli argomenti passati a un oggetto chiamabile non possono essere con parametri di tipo. In questi casi, gli argomenti di tipo devono essere passati insieme a identificatore.

Le versioni precedenti del compilatore Q # consentivano di fornire un valore di funzione dove era previsto un valore di operazione, purché il valore della funzione avesse i tipi di input e output corretti. Si tratta di un comportamento imprevisto non specificato nella specifica del linguaggio Q #.
Nel compilatore 0,3 è stato rimosso questo comportamento in modo che i valori di funzione non siano più considerati valori dell'operazione.
Per ridurre al minimo l'alterazione del codice esistente che si basava su questo bug, è stata aggiunta la funzione tooperation nello spazio dei nomi Microsoft. Quantum. Canon che converte in modo esplicito una funzione in un'operazione con gli stessi tipi di input e di output.

Nell'esempio seguente viene illustrato come utilizzare la funzione `ToOperation` per modificare una funzione `Square` a un'operazione `op`: 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

# <a name="requirements"></a>Requisiti #

La versione è supportata in Visual Studio 2017 versione 15,8 o successiva per Windows 10 e in Visual Studio Code versione 1.27.2 o successiva per Windows 10, macOS e Linux.

Quantum Development Kit usa il .NET Core SDK (2,0 o versione successiva).

# <a name="installation"></a>Installazione  #

Seguire le istruzioni di installazione [qui](../install-guide/index.md).

È possibile che vengano visualizzati avvisi ("conflitti trovati tra versioni diverse di" System. Reflection. Metadata "che non è stato possibile risolvere") se la versione corrente di .NET Core SDK non è aggiornata.  Tuttavia, se si usa .NET Core SDK (2,0 o versione successiva), questi avvisi possono essere ignorati.


- La versione è fornita insieme a diversi esempi che illustrano come usare le funzionalità esistenti del kit di sviluppo Quantum e le nuove funzionalità disponibili in questa versione. È possibile trovare questi esempi in GitHub nel repository [Microsoft/Quantum](https://github.com/Microsoft/Quantum) .


#<a name="Migration"></a>Migrazione di progetti esistenti a Q # 0,3 #

Se sono presenti progetti Q # esistenti dalla versione 0,2 del quantum Development Kit, di seguito sono riportati i passaggi per eseguire la migrazione di tali progetti alla versione più recente. Viene anche fornito uno [script di migrazione](#MigrationScript) per semplificare il processo.

> [!NOTE]
> È necessario aggiornare i progetti in ordine. Se si dispone di una soluzione con più progetti, aggiornare ogni progetto nell'ordine in cui si fa riferimento.


1. Dalla riga di comando eseguire `dotnet clean` per rimuovere tutti i file binari e i file intermedi esistenti.
2. In un editor di testo modificare il file con estensione csproj per modificare la versione di tutti i `PackageReference` "Microsoft. Quantum" nella versione 0.3.1811.2802-Preview, ad esempio:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. Dalla riga di comando, usare lo strumento di formattazione integrato nel compilatore della riga di comando per risolvere tutte le modifiche della sintassi eseguendo questo comando: `dotnet msbuild /t:qsharpformat`  
    - Verrà eseguita la migrazione dei file sul posto. Verrà copiato un backup di tutti i file originali `obj\qsharp\.backup`
    - Lo strumento di formattazione compilerà il progetto ignorando tutti gli errori di compilazione e genererà il codice Q # formattato in base alla compilazione della compilazione. 
       Eventuali simboli non riconosciuti, ad esempio un nome di variabile non definito, verranno sostituiti da un testo segnaposto che deve essere sostituito manualmente dopo la formattazione. In questo caso, la formattazione ha esito positivo durante la generazione di un avviso per il file interessato.     
    - La formattazione e in particolare gli spazi vuoti nel file verranno modificati nel codice generato. I commenti verranno conservati.   
5. Dopo aver eseguito questa operazione, potrebbe essere necessario risolvere manualmente le modifiche semantiche nei casi in cui l'interpretazione semantica del codice è cambiata. Tutti questi errori verranno segnalati da IntelliSense in Visual Studio o Visual Studio Code.
    - Aprire la cartella radice del progetto o la soluzione contenitore in Visual Studio 2017 o Visual Studio Code.
    - Dopo l'apertura di un file. QS nell'editor, l'output dell'estensione del linguaggio Q # verrà visualizzato nella finestra output.
    - Dopo che il progetto è stato caricato correttamente (indicato nella finestra output), aprire ogni file e manualmente per risolvere tutti i problemi rimanenti.


> [!NOTE]
> * Per la versione 0,3, il server di linguaggio incluso in Quantum Development Kit non supporta più aree di lavoro.
> * Per utilizzare un progetto in Visual Studio Code, aprire la cartella radice contenente il progetto stesso e tutti i progetti a cui si fa riferimento.   
> * Per lavorare con una soluzione in Visual Studio, tutti i progetti contenuti nella soluzione devono trovarsi nella stessa cartella della soluzione o in una delle relative sottocartelle.  
> * I riferimenti tra i progetti migrati a 0,3 e versioni successive e i progetti che usano versioni precedenti dei pacchetti **non** sono supportati.




##<a name="MigrationScript"></a>Script di migrazione ##

Per semplificare la migrazione del progetto, viene fornito uno script di PowerShell che può essere scaricato [qui](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).
Questo script consente di migrare i progetti dalla versione 0,2 del quantum Development Kit per usare la versione 0,3.

> [!NOTE]
> Lo script di migrazione richiede l'esecuzione di Windows PowerShell o PowerShell core.
> Windows PowerShell è preinstallato con Windows 10.
> Scaricare PowerShell core per Windows, macOS o Linux in https://github.com/PowerShell/PowerShell.

Lo script esegue i quattro passaggi seguenti:

- Il progetto viene compilato con la versione precedente di Quantum Development Kit per garantire che la migrazione abbia probabilmente esito positivo. Questo passaggio può essere ignorato utilizzando il parametro `-Force` per lo script.
- Sono installati nuovi modelli di progetto.
- Il progetto viene aggiornato per usare la versione corrente di Quantum Development Kit.
- Lo strumento di formattazione fornito con la versione 0,3 di Quantum Development Kit viene applicato per risolvere automaticamente la maggior parte delle modifiche di rilievo documentate in precedenza.

Al termine di questi quattro passaggi, potrebbero verificarsi alcuni problemi di migrazione rimanenti che devono essere gestiti manualmente.
L'uso della versione più recente di Quantum Development Kit Extensions per Visual Studio 2017 e Visual Studio Code può aiutarti a trovare facilmente questi problemi.

La documentazione per lo script può essere ottenuta eseguendo uno dei comandi seguenti nella cartella in cui si trova lo script:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> Per impostazione predefinita, Windows impedisce l'esecuzione di qualsiasi script come misura di sicurezza.
> Per consentire l'esecuzione di script come `qdk-migrate.ps1` in Windows, potrebbe essere necessario modificare i criteri di esecuzione.
> A tale scopo, eseguire il comando `Set-ExecutionPolicy`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> Quando si esce da PowerShell, i criteri di esecuzione verranno ripristinati.
> Se si desidera salvare i criteri di esecuzione, utilizzare un valore diverso per `-Scope`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

