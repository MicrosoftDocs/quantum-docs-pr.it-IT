---
title: "Principi di progettazione dell'API Q #"
description: "Principi di progettazione dell'API Q #"
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
ms.openlocfilehash: 03c32331f8988181ec6fedcfc207d752b4a880b2
ms.sourcegitcommit: d61b388651351e5abd4bfe7a672e88b84a6697f8
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/10/2020
ms.locfileid: "79024203"
---
# <a name="q-api-design-principles"></a><span data-ttu-id="261f1-103">Principi di progettazione dell'API Q #</span><span class="sxs-lookup"><span data-stu-id="261f1-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="261f1-104">Introduzione</span><span class="sxs-lookup"><span data-stu-id="261f1-104">Introduction</span></span>

<span data-ttu-id="261f1-105">In quanto linguaggio e piattaforma, Q # consente agli utenti di scrivere, eseguire, comprendere ed esplorare le applicazioni Quantum.</span><span class="sxs-lookup"><span data-stu-id="261f1-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="261f1-106">Per consentire agli utenti di progettare librerie Q #, seguiamo un set di principi di progettazione dell'API per guidare i nostri progetti e per rendere disponibili librerie utilizzabili per la community di sviluppo Quantum.</span><span class="sxs-lookup"><span data-stu-id="261f1-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="261f1-107">Questo articolo elenca questi principi e fornisce esempi per guidarne l'applicazione durante la progettazione di API Q #.</span><span class="sxs-lookup"><span data-stu-id="261f1-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="261f1-108">Si tratta di un documento piuttosto dettagliato che consente di semplificare lo sviluppo di librerie e i contributi di librerie approfondite.</span><span class="sxs-lookup"><span data-stu-id="261f1-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="261f1-109">Probabilmente è molto utile se si scrivono librerie personalizzate in Q # o se si contribuiscono a ottenere funzionalità di maggiori dimensioni nel [repository delle librerie Q #](https://github.com/microsoft/QuantumLibraries).</span><span class="sxs-lookup"><span data-stu-id="261f1-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="261f1-110">D'altra parte, se si desidera apprendere come contribuire più in generale al quantum Development Kit, è consigliabile iniziare con la [Guida ai contributi](xref:microsoft.quantum.contributing).</span><span class="sxs-lookup"><span data-stu-id="261f1-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="261f1-111">Per informazioni più generali su come si consiglia di formattare il codice Q #, potrebbe essere interessante consultare la [Guida di stile](xref:microsoft.quantum.contributing.style).</span><span class="sxs-lookup"><span data-stu-id="261f1-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="261f1-112">Principi generali</span><span class="sxs-lookup"><span data-stu-id="261f1-112">General Principles</span></span>

<span data-ttu-id="261f1-113">**Principio chiave:** Esporre le API che attivano le applicazioni Quantum.</span><span class="sxs-lookup"><span data-stu-id="261f1-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="261f1-114">✅ **scegliere** i nomi delle operazioni e delle funzioni che riflettono la struttura di alto livello di algoritmi e applicazioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="261f1-115">⛔️ **non** esporre API incentrate principalmente sui dettagli di implementazione di basso livello.</span><span class="sxs-lookup"><span data-stu-id="261f1-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="261f1-116">**Principio chiave:** Avviare ogni progettazione di API con casi d'uso di esempio per garantire che le API siano intuitive da usare.</span><span class="sxs-lookup"><span data-stu-id="261f1-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="261f1-117">✅ **assicurarsi** che ogni componente di un'API pubblica disponga di un caso d'uso corrispondente, anziché provare a progettare per tutti i possibili utilizzi dall'inizio.</span><span class="sxs-lookup"><span data-stu-id="261f1-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="261f1-118">In modo diverso, non introdurre API pubbliche nel caso in cui siano utili, ma assicurarsi che ogni parte di un'API abbia un esempio *concreto* in cui sarà utile.</span><span class="sxs-lookup"><span data-stu-id="261f1-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="261f1-119">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-119">*Examples:*</span></span>
  - <span data-ttu-id="261f1-120">@"microsoft.quantum.canon.applytoeachca" può essere usato come `ApplyToEachCA(H, _)` per preparare i registri in uno stato di superposizione uniforme, un'attività comune in molti algoritmi quantistici.</span><span class="sxs-lookup"><span data-stu-id="261f1-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="261f1-121">La stessa operazione può essere utilizzata anche per molte altre attività di preparazione, valori numerici e algoritmi basati su Oracle.</span><span class="sxs-lookup"><span data-stu-id="261f1-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="261f1-122">✅ **sono** disponibili Brainstorm e workshop sui nuovi progetti API per verificare che siano intuitivi e soddisfino i casi di utilizzo proposti.</span><span class="sxs-lookup"><span data-stu-id="261f1-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="261f1-123">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-123">*Examples:*</span></span>
  - <span data-ttu-id="261f1-124">Esaminare il codice Q\# corrente per vedere come le nuove progettazioni API possono semplificare e chiarire le implementazioni esistenti.</span><span class="sxs-lookup"><span data-stu-id="261f1-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="261f1-125">Esaminare le progettazioni dell'API proposte con i rappresentanti dei gruppi di destinatari primari.</span><span class="sxs-lookup"><span data-stu-id="261f1-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="261f1-126">**Principio chiave:** Progettare API per supportare e incoraggiare codice leggibile.</span><span class="sxs-lookup"><span data-stu-id="261f1-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="261f1-127">✅ **assicurarsi** che il codice sia leggibile da esperti di dominio e non esperti.</span><span class="sxs-lookup"><span data-stu-id="261f1-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="261f1-128">✅ **DO** concentrare l'attenzione sugli effetti di ogni operazione e funzione all'interno dell'algoritmo di alto livello, usando la documentazione per approfondire i dettagli di implementazione in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="261f1-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="261f1-129">✅ **seguire** la Guida di [stile comune Q\#](xref:microsoft.quantum.contributing.style) quando applicabile.</span><span class="sxs-lookup"><span data-stu-id="261f1-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="261f1-130">**Principio chiave:** Progettare le API in modo che siano stabili e forniscano compatibilità con le edizioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="261f1-131">✅ deprecare normalmente le **API obsolete** quando sono necessarie modifiche di rilievo.</span><span class="sxs-lookup"><span data-stu-id="261f1-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="261f1-132">✅ **forniscono** le operazioni "shim" e le funzioni che consentono il corretto funzionamento del codice utente esistente durante la deprecazione.</span><span class="sxs-lookup"><span data-stu-id="261f1-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="261f1-133">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-133">*Examples:*</span></span>
  - <span data-ttu-id="261f1-134">Quando si rinomina un'operazione denominata `EstimateExpectation` `EstimateAverage`, introdurre una nuova operazione denominata `EstimateExpectation` che chiama l'operazione originale con il nuovo nome, in modo che il codice esistente possa continuare a funzionare correttamente.</span><span class="sxs-lookup"><span data-stu-id="261f1-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="261f1-135">✅ **utilizzare** l'attributo @"microsoft.quantum.core.deprecated" per comunicare le deprecazioni all'utente.</span><span class="sxs-lookup"><span data-stu-id="261f1-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="261f1-136">✅ quando si rinomina un'operazione o una funzione **, specificare** il nuovo nome come input di stringa per `@Deprecated`.</span><span class="sxs-lookup"><span data-stu-id="261f1-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="261f1-137">⛔️ **non** rimuovere le funzioni o le operazioni esistenti senza un periodo di deprecazione di almeno sei mesi per le versioni di anteprima o almeno due anni per le versioni supportate.</span><span class="sxs-lookup"><span data-stu-id="261f1-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="261f1-138">Funzioni e operazioni</span><span class="sxs-lookup"><span data-stu-id="261f1-138">Functions and Operations</span></span>

<span data-ttu-id="261f1-139">**Principio chiave:** assicurarsi che ogni funzione e operazione abbia un solo scopo ben definito all'interno dell'API.</span><span class="sxs-lookup"><span data-stu-id="261f1-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="261f1-140">⛔️ **non** esporre funzioni e operazioni che eseguono più attività non correlate.</span><span class="sxs-lookup"><span data-stu-id="261f1-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="261f1-141">**Principio chiave:** le funzioni e le operazioni di progettazione sono riutilizzabili come possibile e per prevedere le esigenze future.</span><span class="sxs-lookup"><span data-stu-id="261f1-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="261f1-142">✅ **le** funzioni e le operazioni di progettazione per comporre correttamente con altre funzioni e operazioni, sia nella stessa API che nelle librerie precedentemente esistenti.</span><span class="sxs-lookup"><span data-stu-id="261f1-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="261f1-143">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-143">*Examples:*</span></span>
  - <span data-ttu-id="261f1-144">L'operazione @"microsoft.quantum.canon.delay" esegue presupposti minimi sull'input e può quindi essere usata per ritardare le applicazioni di entrambe le operazioni nella libreria standard Q # o in base a quanto definito dagli utenti.</span><span class="sxs-lookup"><span data-stu-id="261f1-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="261f1-145">✅ **esporre** la logica classica puramente deterministica come funzioni anziché operazioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="261f1-146">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-146">*Examples:*</span></span>
  - <span data-ttu-id="261f1-147">Una subroutine che consente di eseguire la scrittura in modo deterministico dei quadrati dell'input a virgola mobile e deve quindi essere esposta all'utente come `Squared : Double -> Double` anziché come operazione `Square : Double => Double`.</span><span class="sxs-lookup"><span data-stu-id="261f1-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="261f1-148">Questo consente la chiamata della subroutine in più posizioni, ad esempio all'interno di altre funzioni, e fornisce informazioni di ottimizzazione utili al compilatore che possono influire sulle prestazioni e sulle ottimizzazioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="261f1-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` e `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differiscono dalle garanzie effettuate per quanto riguarda il determinismo; entrambi sono utili in circostanze diverse.</span><span class="sxs-lookup"><span data-stu-id="261f1-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="261f1-150">Le routine API che trasformano l'applicazione delle operazioni Quantum possono spesso essere eseguite in modo deterministico e pertanto possono essere rese disponibili come funzioni come `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span><span class="sxs-lookup"><span data-stu-id="261f1-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="261f1-151">✅ **DO** generalizzare il tipo di input quanto più ragionevole per ogni funzione e operazione, usando i parametri di tipo in base alle esigenze.</span><span class="sxs-lookup"><span data-stu-id="261f1-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="261f1-152">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-152">*Examples:*</span></span>
  - <span data-ttu-id="261f1-153">il tipo di `ApplyToEach` è `<'T>(('T => Unit), 'T[]) => Unit` anziché il tipo specifico dell'applicazione più comune, `((Qubit => Unit), Qubit[]) => Unit`.</span><span class="sxs-lookup"><span data-stu-id="261f1-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="261f1-154">È importante prevedere le esigenze future, ma è importante anche risolvere problemi concreti per gli utenti.</span><span class="sxs-lookup"><span data-stu-id="261f1-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="261f1-155">Agendo su questo principio chiave, in questo modo è sempre necessario prestare particolare attenzione e bilanciamento per evitare di sviluppare API "solo nel caso".</span><span class="sxs-lookup"><span data-stu-id="261f1-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="261f1-156">**Principio chiave:** scegliere i tipi di input e di output per le funzioni e le operazioni stimabili e che comunicano lo scopo di un oggetto chiamabile.</span><span class="sxs-lookup"><span data-stu-id="261f1-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="261f1-157">✅ **utilizzare** i tipi di tupla per raggruppare in modo logico gli input e gli output che sono significativi solo se considerati insieme.</span><span class="sxs-lookup"><span data-stu-id="261f1-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="261f1-158">In questi casi è consigliabile utilizzare un tipo definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="261f1-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="261f1-159">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-159">*Examples:*</span></span>
  - <span data-ttu-id="261f1-160">Una funzione per l'output del valore minimo locale di un'altra funzione potrebbe dover prendere i limiti di un intervallo di ricerca come input, in modo che `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` possa essere una firma appropriata.</span><span class="sxs-lookup"><span data-stu-id="261f1-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="261f1-161">Un'operazione per stimare un derivato di un classificatore di Machine Learning usando la tecnica di spostamento dei parametri potrebbe dover usare i vettori di parametri spostati e non spostati come input.</span><span class="sxs-lookup"><span data-stu-id="261f1-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="261f1-162">In questo caso, un input simile a `(unshifted : Double[], shifted : Double[])` potrebbe essere appropriato.</span><span class="sxs-lookup"><span data-stu-id="261f1-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="261f1-163">✅ **ordinare** gli elementi nelle Tuple di input e output in modo coerente tra funzioni e operazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="261f1-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="261f1-164">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-164">*Examples:*</span></span>
  - <span data-ttu-id="261f1-165">Se si considerano due o funzioni o operazioni che accettano un angolo di rotazione e un qubit di destinazione come input, assicurarsi che siano ordinati allo stesso modo in ogni tupla di input.</span><span class="sxs-lookup"><span data-stu-id="261f1-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="261f1-166">Ovvero preferiscono `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` e `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` e `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="261f1-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="261f1-167">**Principio chiave:** le funzioni e le operazioni di progettazione funzionano bene con le funzionalità del linguaggio Q\# come l'applicazione parziale.</span><span class="sxs-lookup"><span data-stu-id="261f1-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="261f1-168">✅ **ordinare** gli elementi delle tuple di input in modo che gli input applicati più comunemente si verifichino per primi, ad esempio, in modo che l'applicazione parziale agisca in modo analogo al currying.</span><span class="sxs-lookup"><span data-stu-id="261f1-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="261f1-169">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-169">*Examples:*</span></span>
  - <span data-ttu-id="261f1-170">Un'operazione `ApplyRotation` che accetta un numero a virgola mobile e un qubit come input può spesso essere applicata parzialmente con l'input a virgola mobile per l'uso con operazioni che prevedono un input di tipo `Qubit => Unit`.</span><span class="sxs-lookup"><span data-stu-id="261f1-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="261f1-171">Quindi, una firma di `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="261f1-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="261f1-172">funzionerebbe in modo più coerente con l'applicazione parziale.</span><span class="sxs-lookup"><span data-stu-id="261f1-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="261f1-173">In genere, questo materiale sussidiario significa inserire tutti i dati classici prima di tutti qubits nelle Tuple di input, ma usare un giudizio valido ed esaminare il modo in cui l'API viene chiamata in pratica.</span><span class="sxs-lookup"><span data-stu-id="261f1-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="261f1-174">Tipi definiti dall'utente</span><span class="sxs-lookup"><span data-stu-id="261f1-174">User-Defined Types</span></span>

<span data-ttu-id="261f1-175">**Principio chiave:** usare i tipi definiti dall'utente per rendere le API più espressive e convenienti da usare.</span><span class="sxs-lookup"><span data-stu-id="261f1-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="261f1-176">✅ **DO** introducono nuovi tipi definiti dall'utente per fornire un'abbreviazione utile per i tipi lunghi e/o complessi.</span><span class="sxs-lookup"><span data-stu-id="261f1-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="261f1-177">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-177">*Examples:*</span></span>
  - <span data-ttu-id="261f1-178">Nei casi in cui un tipo di operazione con tre input di matrice qubit viene comunemente usato come input o restituito come output, fornendo un tipo definito dall'utente, ad esempio `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="261f1-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="261f1-179">consente di fornire un'utile abbreviazione.</span><span class="sxs-lookup"><span data-stu-id="261f1-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="261f1-180">✅ **DO** introducono nuovi tipi definiti dall'utente per indicare che un determinato tipo di base deve essere utilizzato solo in un senso molto particolare.</span><span class="sxs-lookup"><span data-stu-id="261f1-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="261f1-181">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-181">*Examples:*</span></span>
  - <span data-ttu-id="261f1-182">Un'operazione che deve essere interpretata in modo specifico come operazione che codifica i dati classici in un registro quantum può essere appropriata per l'etichetta con un tipo definito dall'utente `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span><span class="sxs-lookup"><span data-stu-id="261f1-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="261f1-183">✅ **DO** introducono nuovi tipi definiti dall'utente con elementi denominati che consentono l'estendibilità futura (ad esempio, una struttura dei risultati che può contenere altri elementi denominati in futuro).</span><span class="sxs-lookup"><span data-stu-id="261f1-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="261f1-184">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-184">*Examples:*</span></span>
  - <span data-ttu-id="261f1-185">Quando un'operazione `TrainModel` espone un numero elevato di opzioni di configurazione, l'esposizione di queste opzioni come nuovo UDT `TrainingOptions` e la fornitura di una nuova funzione `DefaultTrainingOptions : Unit -> TrainingOptions` consente agli utenti di eseguire l'override di elementi denominati specifici nei valori UDT TrainingOptions, consentendo allo stesso tempo agli sviluppatori di librerie di aggiungere nuovi elementi UDT nel modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="261f1-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="261f1-186">✅ **dichiarare** gli elementi denominati per i nuovi tipi definiti dall'utente in modo da richiedere agli utenti di comprendere la decostruzione corretta della tupla.</span><span class="sxs-lookup"><span data-stu-id="261f1-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="261f1-187">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-187">*Examples:*</span></span>
  - <span data-ttu-id="261f1-188">Quando si rappresenta un numero complesso nella relativa scomposizione polare, preferire `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` `newtype ComplexPolar = (Double, Double)`.</span><span class="sxs-lookup"><span data-stu-id="261f1-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="261f1-189">**Principio chiave:** usare i tipi definiti dall'utente in modo da ridurre il carico cognitivo e non richiedere all'utente di apprendere concetti e nomenclatura aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="261f1-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="261f1-190">⛔️ **non** introducono tipi definiti dall'utente che richiedono l'uso frequente dell'operatore Unwrap (`!`) o che richiedono in genere più livelli di annullamento del wrapping.</span><span class="sxs-lookup"><span data-stu-id="261f1-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="261f1-191">Le strategie di mitigazione possibili includono:</span><span class="sxs-lookup"><span data-stu-id="261f1-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="261f1-192">Quando si espone un tipo definito dall'utente con un singolo elemento, è consigliabile definire un nome per l'elemento.</span><span class="sxs-lookup"><span data-stu-id="261f1-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="261f1-193">Si consideri, ad esempio, `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` preferenza a `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="261f1-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="261f1-194">Assicurandosi che altre funzioni e operazioni possano accettare direttamente le istanze del tipo definito dall'utente "Wrapped".</span><span class="sxs-lookup"><span data-stu-id="261f1-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="261f1-195">⛔️ **non** introducono nuovi tipi definiti dall'utente che duplicano i tipi incorporati senza fornire un'espressività aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="261f1-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="261f1-196">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-196">*Examples:*</span></span>
  - <span data-ttu-id="261f1-197">Un tipo definito dall'utente `newtype QubitRegister = Qubit[]` non fornisce espressività aggiuntiva rispetto `Qubit[]`ed è quindi più difficile da usare senza alcun vantaggio distinguibile.</span><span class="sxs-lookup"><span data-stu-id="261f1-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="261f1-198">Un tipo definito dall'utente `newtype LittleEndian = Qubit[]` documenta il modo in cui deve essere usato e interpretato il registro sottostante e quindi fornisce un'espressività aggiuntiva sul relativo tipo di base.</span><span class="sxs-lookup"><span data-stu-id="261f1-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="261f1-199">⛔️ **non** introducono funzioni di accesso a meno che non sia strettamente necessario;   in questo caso, è consigliabile preferire gli elementi denominati.</span><span class="sxs-lookup"><span data-stu-id="261f1-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="261f1-200">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-200">*Examples:*</span></span>
  - <span data-ttu-id="261f1-201">Quando si introduce un tipo definito dall'utente `newtype Complex = (Double, Double)`, è preferibile modificare la definizione per `newtype Complex = (Real : Double, Imag : Double)` all'introduzione di funzioni `GetReal : Complex -> Double` e `GetImag : Complex -> Double`.</span><span class="sxs-lookup"><span data-stu-id="261f1-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="261f1-202">Spazi dei nomi e organizzazione</span><span class="sxs-lookup"><span data-stu-id="261f1-202">Namespaces and Organization</span></span>

<span data-ttu-id="261f1-203">**Principio chiave:** scegliere i nomi degli spazi dei nomi stimabili e che comunicano chiaramente lo scopo di funzioni, operazioni e tipi definiti dall'utente in ogni spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="261f1-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="261f1-204">✅ gli spazi dei nomi **vengono** denominati come `Publisher.Product.DomainArea`.</span><span class="sxs-lookup"><span data-stu-id="261f1-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="261f1-205">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-205">*Examples:*</span></span>
  - <span data-ttu-id="261f1-206">Le funzioni, le operazioni e i tipi definiti dall'utente pubblicati da Microsoft nell'ambito della funzionalità di simulazione quantistica del quantum Development Kit vengono inseriti nello spazio dei nomi `Microsoft.Quantum.Simulation`.</span><span class="sxs-lookup"><span data-stu-id="261f1-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="261f1-207">`Microsoft.Quantum.Math` rappresenta uno spazio dei nomi pubblicato da Microsoft come parte del quantum Development Kit relativo all'area del dominio matematico.</span><span class="sxs-lookup"><span data-stu-id="261f1-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="261f1-208">✅ **DO** inseriscono operazioni, funzioni e tipi definiti dall'utente utilizzati per funzionalità specifiche in uno spazio dei nomi in cui viene descritta tale funzionalità, anche quando tale funzionalità viene utilizzata in domini problematici diversi.</span><span class="sxs-lookup"><span data-stu-id="261f1-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="261f1-209">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-209">*Examples:*</span></span>
  - <span data-ttu-id="261f1-210">Le API di preparazione dello stato pubblicate da Microsoft come parte del quantum Development Kit verrebbero inserite in `Microsoft.Quantum.Preparation`.</span><span class="sxs-lookup"><span data-stu-id="261f1-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="261f1-211">Le API di simulazione quantistica pubblicate da Microsoft come parte del quantum Development Kit verrebbero inserite in `Microsoft.Quantum.Simulation`.</span><span class="sxs-lookup"><span data-stu-id="261f1-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="261f1-212">✅ inseriscono operazioni, funzioni e tipi definiti dall'utente utilizzati solo all'interno di domini specifici in spazi dei nomi che **ne** indicano il dominio di utilità.</span><span class="sxs-lookup"><span data-stu-id="261f1-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="261f1-213">Se necessario, utilizzare i sottospazi dei nomi per indicare le attività mirate all'interno di ogni spazio dei nomi specifico del dominio.</span><span class="sxs-lookup"><span data-stu-id="261f1-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="261f1-214">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-214">*Examples:*</span></span>
  - <span data-ttu-id="261f1-215">La libreria Quantum Machine Learning pubblicata da Microsoft si trova in gran parte nello spazio dei nomi @"microsoft.quantum.machinelearning", ma i set di impostazioni di esempio vengono forniti dallo spazio dei nomi @"microsoft.quantum.machinelearning.datasets".</span><span class="sxs-lookup"><span data-stu-id="261f1-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="261f1-216">Le API di chimica quantistica pubblicate da Microsoft come parte del quantum Development Kit devono essere inserite in `Microsoft.Quantum.Chemistry`.</span><span class="sxs-lookup"><span data-stu-id="261f1-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="261f1-217">Le funzionalità specifiche dell'implementazione della scomposizione Giordania--Wigner possono essere inserite in `Microsoft.Quantum.Chemistry.JordanWigner`, in modo che l'interfaccia primaria per l'area del dominio di chimica quantistica non sia interessata dalle implementazioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="261f1-218">**Principio chiave:** Usare insieme gli spazi dei nomi e i modificatori di accesso per essere intenzionali sulla superficie dell'API esposta agli utenti e per nascondere i dettagli interni correlati all'implementazione e al test delle API.</span><span class="sxs-lookup"><span data-stu-id="261f1-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="261f1-219">✅ ogni volta che è ragionevole **, inserire tutte** le funzioni e le operazioni necessarie per implementare un'API nello stesso spazio dei nomi dell'API implementata, ma contrassegnata con le parole chiave "private" o "Internal" per indicare che non fanno parte della superficie dell'API pubblica per una raccolta.</span><span class="sxs-lookup"><span data-stu-id="261f1-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="261f1-220">Usare un nome che inizia con un carattere di sottolineatura (`_`) per distinguere visivamente le operazioni e le operazioni private e interne dalle funzioni chiamabili pubbliche.</span><span class="sxs-lookup"><span data-stu-id="261f1-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="261f1-221">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-221">*Examples:*</span></span>
  - <span data-ttu-id="261f1-222">Il nome dell'operazione `_Features` indica una funzione privata per uno spazio dei nomi e un assembly specificati e deve essere accompagnata dalla parola chiave `internal`.</span><span class="sxs-lookup"><span data-stu-id="261f1-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="261f1-223">✅ nel raro caso in cui sia necessario un set completo di funzioni o funzioni private per implementare l'API per un determinato spazio dei **nomi,** inserirle in un nuovo spazio dei nomi che corrisponde allo spazio dei nomi implementato e che termina con `.Private`.</span><span class="sxs-lookup"><span data-stu-id="261f1-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="261f1-224">✅ **eseguire** tutti gli unit test in spazi dei nomi che corrispondono allo spazio dei nomi sottoposto a test e che terminano con `.Tests`.</span><span class="sxs-lookup"><span data-stu-id="261f1-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="261f1-225">Convenzioni di denominazione e vocabolario</span><span class="sxs-lookup"><span data-stu-id="261f1-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="261f1-226">**Principio chiave:** Scegli i nomi e la terminologia che sono chiari, accessibili e leggibili in una vasta gamma di destinatari, inclusi sia i novizi quantistici che gli esperti.</span><span class="sxs-lookup"><span data-stu-id="261f1-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="261f1-227">⛔️ **non** usare nomi di identificatori discriminatori o esclusioni, né la terminologia nei commenti della documentazione dell'API.</span><span class="sxs-lookup"><span data-stu-id="261f1-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="261f1-228">✅ **usare** i commenti relativi alla documentazione API per fornire contesto, esempi e riferimenti pertinenti, soprattutto per concetti più complessi.</span><span class="sxs-lookup"><span data-stu-id="261f1-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="261f1-229">⛔️ **non** usano nomi di identificatore inutilmente esoterici o che richiedono una conoscenza significativa degli algoritmi Quantum da leggere.</span><span class="sxs-lookup"><span data-stu-id="261f1-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="261f1-230">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-230">*Examples:*</span></span>
  - <span data-ttu-id="261f1-231">Preferisce "iterazione di amplificazione dell'ampiezza" a "iterazione Grover".</span><span class="sxs-lookup"><span data-stu-id="261f1-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="261f1-232">✅ **DO** scelgono le operazioni e i nomi di funzione che comunicano chiaramente l'effetto previsto di un oggetto chiamabile e non la relativa implementazione.</span><span class="sxs-lookup"><span data-stu-id="261f1-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="261f1-233">Si noti che l'implementazione può e deve essere</span><span class="sxs-lookup"><span data-stu-id="261f1-233">Note that the implementation can and should be</span></span>

  <span data-ttu-id="261f1-234">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-234">*Examples:*</span></span>
  - <span data-ttu-id="261f1-235">Preferisco "stima sovrapposizione" a "Hadamard test", perché quest'ultimo comunica come viene implementato il primo.</span><span class="sxs-lookup"><span data-stu-id="261f1-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="261f1-236">✅ **usare** parole in modo coerente in tutte le API di Q\#:</span><span class="sxs-lookup"><span data-stu-id="261f1-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="261f1-237">**Verbi**</span><span class="sxs-lookup"><span data-stu-id="261f1-237">**Verbs:**</span></span>

    - <span data-ttu-id="261f1-238">**Assert**: verificare che un presupposto sullo stato di un computer di destinazione e del relativo qubits contenga, possibilmente usando risorse non fisiche.</span><span class="sxs-lookup"><span data-stu-id="261f1-238">**Assert**: Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="261f1-239">Le operazioni che usano questo verbo devono essere sempre rimovibili in modo sicuro senza influire sulla funzionalità delle librerie e dei programmi eseguibili.</span><span class="sxs-lookup"><span data-stu-id="261f1-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="261f1-240">Si noti che, a differenza dei fatti, le asserzioni possono in genere dipendere dallo stato esterno, ad esempio lo stato di un registro qubit, l'ambiente di esecuzione o così via.</span><span class="sxs-lookup"><span data-stu-id="261f1-240">Note that unlike facts, assertions may in general depend on external state, such as the state of a qubit register, the execution environment or so forth.</span></span> <span data-ttu-id="261f1-241">Poiché la dipendenza dallo stato esterno è un tipo di effetto collaterale, le asserzioni devono essere esposte come operazioni anziché come funzioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="261f1-242">**Stima**: utilizzando una o più misurazioni eventualmente ripetute, stimare una quantità classica dai risultati della misurazione.</span><span class="sxs-lookup"><span data-stu-id="261f1-242">**Estimate**: Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="261f1-243">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="261f1-244">**Preparazione**: applicare un'operazione Quantum o una sequenza di operazioni a uno o più qubits si presuppone che si avvii in uno stato iniziale specifico (in genere $ \ket{00\cdots 0} $), causando lo stato di tali qubits per evolversi a uno stato finale desiderato.</span><span class="sxs-lookup"><span data-stu-id="261f1-244">**Prepare**: Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="261f1-245">In generale, l'uso di stati diversi dallo stato di avvio specificato **può** comportare una trasformazione unitaria non definita, ma **deve** comunque mantenere che un'operazione e la relativa annullata "Annulla" e applichino un no-op.</span><span class="sxs-lookup"><span data-stu-id="261f1-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="261f1-246">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="261f1-247">**Measure**: applicare un'operazione Quantum o una sequenza di operazioni a uno o più qubits, leggendo il backup dei dati classici.</span><span class="sxs-lookup"><span data-stu-id="261f1-247">**Measure**: Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="261f1-248">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-248">*Examples:*</span></span>
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="261f1-249">**Apply**: applicare un'operazione Quantum o una sequenza di operazioni a uno o più qubits, causando la modifica dello stato di tali qubits in modo coerente.</span><span class="sxs-lookup"><span data-stu-id="261f1-249">**Apply**: Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="261f1-250">Questo verbo è il verbo più generale nella nomenclatura Q\# e **non deve essere** usato quando un verbo più specifico è più direttamente pertinente.</span><span class="sxs-lookup"><span data-stu-id="261f1-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="261f1-251">**Sostantivi**:</span><span class="sxs-lookup"><span data-stu-id="261f1-251">**Nouns**:</span></span>

    - <span data-ttu-id="261f1-252">**Fact**: condizione booleana che dipende solo dagli input e non dallo stato di un computer di destinazione, dal relativo ambiente o dallo stato del qubits del computer.</span><span class="sxs-lookup"><span data-stu-id="261f1-252">**Fact**: A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="261f1-253">Al contrario di un'asserzione, un fatto è sensibile solo ai *valori* forniti al fatto.</span><span class="sxs-lookup"><span data-stu-id="261f1-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="261f1-254">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="261f1-254">For example:</span></span>

      <span data-ttu-id="261f1-255">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-255">*Examples:*</span></span>
      - <span data-ttu-id="261f1-256">@"microsoft.quantum.diagnostics.equalityfacti": rappresenta un fatto di uguaglianza per due input Integer; i numeri interi specificati come input sono uguali tra loro o non sono, indipendentemente da qualsiasi altro stato del programma.</span><span class="sxs-lookup"><span data-stu-id="261f1-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="261f1-257">**Opzioni:** Tipo definito dall'utente che contiene più elementi denominati che possono fungere da "argomenti facoltativi" per una funzione o un'operazione.</span><span class="sxs-lookup"><span data-stu-id="261f1-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="261f1-258">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="261f1-258">For example:</span></span>

      <span data-ttu-id="261f1-259">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-259">*Examples:*</span></span>
      - <span data-ttu-id="261f1-260">Il tipo definito dall'utente @"microsoft.quantum.machinelearning.trainingoptions" include gli elementi denominati per la velocità di apprendimento, le dimensioni minibatch e altri parametri configurabili per la formazione ML.</span><span class="sxs-lookup"><span data-stu-id="261f1-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="261f1-261">**Aggettivi**:</span><span class="sxs-lookup"><span data-stu-id="261f1-261">**Adjectives**:</span></span>

    - <span data-ttu-id="261f1-262">⛔️ **nuovo**: questo aggettivo **non deve** essere usato, come per evitare confusione con l'utilizzo come verbo in molti linguaggi di programmazione, ad esempio C++, C#, Java, typescript, PowerShell.</span><span class="sxs-lookup"><span data-stu-id="261f1-262">⛔️ **New**: This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="261f1-263">**Preposizioni:** In alcuni casi, è possibile usare le preposizioni per eliminare ulteriormente le ambiguità o chiarire i ruoli di sostantivi e verbi nei nomi delle funzioni e delle operazioni.</span><span class="sxs-lookup"><span data-stu-id="261f1-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="261f1-264">È necessario prestare attenzione a tale scopo, tuttavia, in modo sporadico e coerente.</span><span class="sxs-lookup"><span data-stu-id="261f1-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="261f1-265">**Come:** Indica che l'input e l'output di una funzione rappresentano le stesse informazioni, ma che l'output rappresenta le informazioni **come** una *X* anziché la rappresentazione originale.</span><span class="sxs-lookup"><span data-stu-id="261f1-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="261f1-266">Questa operazione è particolarmente comune per le funzioni di conversione dei tipi.</span><span class="sxs-lookup"><span data-stu-id="261f1-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="261f1-267">*Esempi:*</span><span class="sxs-lookup"><span data-stu-id="261f1-267">*Examples:*</span></span>
      - <span data-ttu-id="261f1-268">`IntAsDouble(2)` indica che l'input (`2`) e l'output (`2.0`) rappresentano in modo qualitativo le stesse informazioni, ma utilizzano diversi tipi di dati Q\# a tale scopo.</span><span class="sxs-lookup"><span data-stu-id="261f1-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="261f1-269">**Da:** Per garantire la coerenza, questa preposizione **non deve** essere utilizzata per indicare funzioni di conversione del tipo o altri casi **in** cui è appropriato.</span><span class="sxs-lookup"><span data-stu-id="261f1-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="261f1-270">⛔️ **:** questa preposizione **non deve** essere utilizzata per evitare confusione con l'utilizzo come verbo in molti linguaggi di programmazione.</span><span class="sxs-lookup"><span data-stu-id="261f1-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
