---
title: 'Nozioni di base su Q #'
description: 'Concetti di base di Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: 45e6f2f33dafc2aec177091d3cfa94aca14fbf0a
ms.sourcegitcommit: af10179284967bd7a72a52ae7e1c4da65c7d128d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/26/2020
ms.locfileid: "85415361"
---
# <a name="q-basics"></a><span data-ttu-id="79bb7-103">Nozioni di base su Q #</span><span class="sxs-lookup"><span data-stu-id="79bb7-103">Q# Basics</span></span>

<span data-ttu-id="79bb7-104">Questo articolo presenta una breve introduzione ai componenti di base di Q #.</span><span class="sxs-lookup"><span data-stu-id="79bb7-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="79bb7-105">Per una panoramica delle funzionalità di Q # e del punto in cui si integra come componente fondamentale del quantum Development Kit, vedere [che cos'è q #?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="79bb7-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="79bb7-106">Che cos'è un programma Quantum?</span><span class="sxs-lookup"><span data-stu-id="79bb7-106">What is a quantum program?</span></span>

<span data-ttu-id="79bb7-107">Dal punto di vista tecnico, un programma Quantum è un particolare set di subroutine classiche che, quando chiamate, eseguono determinate operazioni in un sistema Quantum.</span><span class="sxs-lookup"><span data-stu-id="79bb7-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="79bb7-108">Una conseguenza importante di tale visualizzazione è che un programma Q # non modella direttamente qubits, ma descrive in che modo un computer controllato dal classico interagisce con tali qubits.</span><span class="sxs-lookup"><span data-stu-id="79bb7-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="79bb7-109">Per impostazione predefinita, Q # non definisce gli Stati Quantum o altre proprietà dei meccanismi Quantum direttamente.</span><span class="sxs-lookup"><span data-stu-id="79bb7-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="79bb7-110">Si consideri, ad esempio, lo stato $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ illustrato nella Guida ai [concetti relativi al quantum computing](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="79bb7-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="79bb7-111">Per preparare questo stato in Q #, iniziare con i fatti che qubits vengono inizializzati nello stato $ \ket {0} $ e che $ \ket{+} = H\ket {0} $, dove $H $ è la [trasformazione Hadamard](xref:microsoft.quantum.glossary#hadamard), implementata dall' [ `H` operazione](xref:microsoft.quantum.intrinsic.h).</span><span class="sxs-lookup"><span data-stu-id="79bb7-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:microsoft.quantum.intrinsic.h).</span></span> <span data-ttu-id="79bb7-112">Il codice Q # di base per inizializzare e trasformare un qubit, quindi, ha un aspetto simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="79bb7-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="79bb7-113">Per ulteriori informazioni sull'inizializzazione o l' *allocazione*di qubits, vedere [utilizzo di qubits](xref:microsoft.quantum.guide.qubits).</span><span class="sxs-lookup"><span data-stu-id="79bb7-113">For more information on initializing, or *allocating*, qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-q"></a><span data-ttu-id="79bb7-114">Stati Quantum in Q #</span><span class="sxs-lookup"><span data-stu-id="79bb7-114">Quantum states in Q#</span></span>

<span data-ttu-id="79bb7-115">In particolare, il programma precedente non fa riferimento in modo esplicito allo stato all'interno di Q #, ma descrive il modo in cui il programma ha *trasformato* lo stato.</span><span class="sxs-lookup"><span data-stu-id="79bb7-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="79bb7-116">Con questo approccio, è possibile essere completamente agnostico sullo *stato del quantum anche in ogni* computer di destinazione, che può avere interpretazioni diverse a seconda del computer.</span><span class="sxs-lookup"><span data-stu-id="79bb7-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="79bb7-117">Un programma Q # non può analizzare nello stato di un qubit.</span><span class="sxs-lookup"><span data-stu-id="79bb7-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="79bb7-118">Un programma può invece chiamare operazioni come [`Measure`](xref:microsoft.quantum.intrinsic.measure) per ottenere informazioni da un qubit e chiamare operazioni come [`X`](xref:microsoft.quantum.intrinsic.x) e [`H`](xref:microsoft.quantum.intrinsic.h) per agire sullo stato di un qubit.</span><span class="sxs-lookup"><span data-stu-id="79bb7-118">Instead, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="79bb7-119">Le *operazioni effettivamente eseguite* da queste operazioni sono concretate solo dal computer di destinazione usato per eseguire il programma Q # specifico.</span><span class="sxs-lookup"><span data-stu-id="79bb7-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="79bb7-120">Ad esempio, se si esegue il programma nel [simulatore a stato completo](xref:microsoft.quantum.machines.full-state-simulator), il simulatore esegue le operazioni matematiche corrispondenti al sistema Quantum simulato.</span><span class="sxs-lookup"><span data-stu-id="79bb7-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="79bb7-121">Tuttavia, guardando il futuro, quando il computer di destinazione è un computer Quantum reale, la chiamata di tali operazioni in Q # indirizza il computer Quantum a eseguire le operazioni *effettive* corrispondenti sul sistema Quantum *reale* , ad esempio gli impulsi laser temporizzati.</span><span class="sxs-lookup"><span data-stu-id="79bb7-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="79bb7-122">Un programma Q # ricombina queste operazioni in base a quanto definito da un computer di destinazione per creare nuove operazioni di livello superiore per esprimere il calcolo quantistico.</span><span class="sxs-lookup"><span data-stu-id="79bb7-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="79bb7-123">In questo modo, Q # rende più semplice esprimere gli algoritmi quantistici e Quantum sottostanti alla logica, oltre a essere generali rispetto alla struttura di un computer o di un simulatore di destinazione.</span><span class="sxs-lookup"><span data-stu-id="79bb7-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="79bb7-124">Operazioni e funzioni Q #</span><span class="sxs-lookup"><span data-stu-id="79bb7-124">Q# operations and functions</span></span>

<span data-ttu-id="79bb7-125">In concreto, un programma Q # comprende *operazioni*, *funzioni*e qualsiasi tipo definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="79bb7-125">Concretely, a Q# program comprises *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="79bb7-126">Le operazioni vengono usate per descrivere le trasformazioni dei sistemi quantum e costituiscono il blocco predefinito più fondamentale dei programmi Q #.</span><span class="sxs-lookup"><span data-stu-id="79bb7-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="79bb7-127">Ogni operazione definita in Q # può quindi chiamare un numero qualsiasi di altre operazioni.</span><span class="sxs-lookup"><span data-stu-id="79bb7-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="79bb7-128">Diversamente dalle operazioni, le funzioni vengono usate per descrivere il comportamento classico puramente *deterministico* e non hanno alcun effetto oltre al calcolo dei valori classici.</span><span class="sxs-lookup"><span data-stu-id="79bb7-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="79bb7-129">Si supponga, ad esempio, di voler misurare il qubits alla fine di un programma e aggiungere i risultati della misurazione a una matrice.</span><span class="sxs-lookup"><span data-stu-id="79bb7-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="79bb7-130">In questo caso, `Measure` è un' *operazione* che indica al computer di destinazione di eseguire una misurazione sulla qubits (reale o simulata).</span><span class="sxs-lookup"><span data-stu-id="79bb7-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="79bb7-131">Allo stesso tempo, le *funzioni* gestiscono il processo classico di aggiunta dei risultati restituiti a una matrice.</span><span class="sxs-lookup"><span data-stu-id="79bb7-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="79bb7-132">Insieme, le operazioni e le funzioni sono note come *chiamabili*.</span><span class="sxs-lookup"><span data-stu-id="79bb7-132">Together, operations and functions are known as *callables*.</span></span> <span data-ttu-id="79bb7-133">La struttura e il comportamento sottostanti vengono introdotti e descritti in dettaglio in [operazioni e funzioni in Q #](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="79bb7-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="79bb7-134">Cenni preliminari sulla sintassi Q #</span><span class="sxs-lookup"><span data-stu-id="79bb7-134">Q# syntax overview</span></span>

<span data-ttu-id="79bb7-135">La sintassi di un linguaggio descrive le diverse combinazioni di simboli che formano un programma sintatticamente corretto.</span><span class="sxs-lookup"><span data-stu-id="79bb7-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="79bb7-136">In Q # gli elementi di sintassi sono classificati in tre gruppi diversi: tipi, espressioni e istruzioni.</span><span class="sxs-lookup"><span data-stu-id="79bb7-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="79bb7-137">Tipi</span><span class="sxs-lookup"><span data-stu-id="79bb7-137">Types</span></span>
<span data-ttu-id="79bb7-138">Q # è un linguaggio fortemente tipizzato, in modo che l'utilizzo accurato dei tipi possa aiutare il compilatore a fornire garanzie complesse sui programmi Q # in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="79bb7-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="79bb7-139">Oltre ai tipi primitivi predefiniti standard e specifici di Quantum, ad esempio,,, `Int` `Bool` `Qubit` e `Result` , Q # fornisce supporto per i tipi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="79bb7-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="79bb7-140">Per le descrizioni di tutti i tipi primitivi, i dettagli per i tipi di matrice e di tupla e i passaggi per definire nuovi tipi in un file Q #, vedere [tipi in q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="79bb7-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="79bb7-141">Espressioni</span><span class="sxs-lookup"><span data-stu-id="79bb7-141">Expressions</span></span>
<span data-ttu-id="79bb7-142">Un'espressione in un linguaggio di programmazione è una combinazione di una o più costanti, variabili, operatori e funzioni che il linguaggio di programmazione interpreta e restituisce un valore specifico.</span><span class="sxs-lookup"><span data-stu-id="79bb7-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="79bb7-143">Più semplicemente, per ogni tipo in un linguaggio, le espressioni di quel tipo possono essere *valori letterali* o simboli associati a un valore di quel tipo.</span><span class="sxs-lookup"><span data-stu-id="79bb7-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="79bb7-144">Ad esempio, `5` è un valore `Int` letterale (quindi anche un'espressione di tipo `Int` ) e se il simbolo `count` è associato al valore integer `5` , `count` è anche un'espressione Integer.</span><span class="sxs-lookup"><span data-stu-id="79bb7-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="79bb7-145">Inoltre, un'espressione può essere costituita da altre espressioni combinate da determinati operatori.</span><span class="sxs-lookup"><span data-stu-id="79bb7-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="79bb7-146">Ad esempio, un'altra `Int` espressione che restituisce `5` è `2+3` .</span><span class="sxs-lookup"><span data-stu-id="79bb7-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="79bb7-147">Per ulteriori informazioni sulle espressioni e gli operatori compatibili in Q #, vedere [espressioni di tipo in q #](xref:microsoft.quantum.guide.expressions).</span><span class="sxs-lookup"><span data-stu-id="79bb7-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="79bb7-148">Istruzioni</span><span class="sxs-lookup"><span data-stu-id="79bb7-148">Statements</span></span> 
<span data-ttu-id="79bb7-149">Un'istruzione è un'unità sintattica di un linguaggio di programmazione imperativo che esprime un'azione da eseguire. Le istruzioni sono in contrasto con le espressioni presenti nelle istruzioni che non restituiscono risultati e vengono eseguite esclusivamente per gli effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="79bb7-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects.</span></span> <span data-ttu-id="79bb7-150">Le espressioni, tuttavia, restituiscono sempre un risultato e spesso non hanno effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="79bb7-150">Expressions, however, always return a result and often do not have side effects at all.</span></span> <span data-ttu-id="79bb7-151">In breve, le istruzioni Q # vengono eseguite, mentre le espressioni vengono valutate.</span><span class="sxs-lookup"><span data-stu-id="79bb7-151">In short, Q# statements are executed, while expressions are evaluated.</span></span>

<span data-ttu-id="79bb7-152">Un semplice esempio di istruzione in Q # consiste nell'assegnare un simbolo a un'espressione:</span><span class="sxs-lookup"><span data-stu-id="79bb7-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="79bb7-153">Un esempio più interessante è l' `for` istruzione che supporta l'iterazione e include un *blocco di istruzioni*.</span><span class="sxs-lookup"><span data-stu-id="79bb7-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="79bb7-154">`qubits`Si supponga che sia il simbolo associato a un registro di qubits (tecnicamente di tipo `Qubit[]` o una matrice di `Qubit` tipi).</span><span class="sxs-lookup"><span data-stu-id="79bb7-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="79bb7-155">Risultato</span><span class="sxs-lookup"><span data-stu-id="79bb7-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="79bb7-156">è un'istruzione che esegue l'iterazione di ogni qubit nel registro, eseguendo l' `H` operazione su ciascuna di esse.</span><span class="sxs-lookup"><span data-stu-id="79bb7-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="79bb7-157">Si noti che `H(qubit);` si tratta anche di un'istruzione.</span><span class="sxs-lookup"><span data-stu-id="79bb7-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="79bb7-158">È possibile usare qualsiasi espressione chiamata di tipo `Unit` (un `Unit` tipo non restituisce alcuna informazione) come istruzione.</span><span class="sxs-lookup"><span data-stu-id="79bb7-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="79bb7-159">Questo tipo di espressione è utile quando si chiamano le operazioni su qubits che restituiscono `Unit` perché lo scopo dell'istruzione è modificare lo stato quantum implicito.</span><span class="sxs-lookup"><span data-stu-id="79bb7-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="79bb7-160">Le istruzioni di valutazione dell'espressione richiedono un punto e virgola di terminazione.</span><span class="sxs-lookup"><span data-stu-id="79bb7-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="79bb7-161">Si usano istruzioni per compilare quasi ogni aspetto di un programma Q # e nessuna pagina può includere tutte le informazioni correlate.</span><span class="sxs-lookup"><span data-stu-id="79bb7-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="79bb7-162">Per ulteriori informazioni sulla struttura lessicale e la formattazione, vedere la pagina relativa alla [struttura dei file Q #](xref:microsoft.quantum.guide.filestructure). per l'assegnazione di associazioni di simboli e l'ambito, vedere [variabili in Q #](xref:microsoft.quantum.guide.variables); per i cicli del flusso di controllo `for` , ad esempio, vedere [flusso di controllo in Q #](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="79bb7-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="79bb7-163">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="79bb7-163">Next steps</span></span>

<span data-ttu-id="79bb7-164">Inizia a conoscere i [tipi in Q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="79bb7-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="79bb7-165">Per informazioni più dettagliate sulle fondamenta e la motivazione alla base di Q #, vedere [perché è necessario q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="79bb7-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
