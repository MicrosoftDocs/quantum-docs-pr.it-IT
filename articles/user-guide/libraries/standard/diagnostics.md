---
title: Diagnostica nelle Q# librerie standard
description: Informazioni sulle funzioni e sulle operazioni di diagnostica nelle Q# librerie standard usate per rilevare errori o errori nei programmi Quantum.
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: d13122187a24893d297cfdbb3ad4db03eb22ded0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858694"
---
# <a name="diagnostics"></a><span data-ttu-id="064b9-103">Diagnostica</span><span class="sxs-lookup"><span data-stu-id="064b9-103">Diagnostics</span></span> #

<span data-ttu-id="064b9-104">Come per lo sviluppo classico, è importante essere in grado di diagnosticare errori ed errori nei programmi Quantum.</span><span class="sxs-lookup"><span data-stu-id="064b9-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="064b9-105">Le Q# librerie standard forniscono diversi modi per garantire la correttezza dei programmi Quantum, come descritto in <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="064b9-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="064b9-106">In gran parte, questo supporto viene fornito sotto forma di funzioni e operazioni che indicano al computer di destinazione di fornire informazioni di diagnostica aggiuntive al programma host o allo sviluppatore oppure di applicare la correttezza delle condizioni e delle invarianti espresse dalla funzione o dalla chiamata dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="064b9-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="064b9-107">Diagnostica del computer</span><span class="sxs-lookup"><span data-stu-id="064b9-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="064b9-108">La diagnostica sui valori classici può essere ottenuta usando la <xref:Microsoft.Quantum.Intrinsic.Message> funzione per registrare un messaggio in modo dipendente dal computer.</span><span class="sxs-lookup"><span data-stu-id="064b9-108">Diagnostics about classical values can be obtained by using the <xref:Microsoft.Quantum.Intrinsic.Message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="064b9-109">Per impostazione predefinita, la stringa viene scritta nella console.</span><span class="sxs-lookup"><span data-stu-id="064b9-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="064b9-110">Utilizzato insieme alle stringhe interpolate, <xref:Microsoft.Quantum.Intrinsic.Message> semplifica la segnalazione di informazioni di diagnostica sui valori classici:</span><span class="sxs-lookup"><span data-stu-id="064b9-110">Used together with interpolated strings, <xref:Microsoft.Quantum.Intrinsic.Message> makes it easy to report diagnostic information about classical values:</span></span>

```qsharp
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="064b9-111">`Message` con la firma `(String -> Unit)` , che rappresenta di nuovo che la creazione di un messaggio di log di debug non può essere osservata dall'interno di Q# .</span><span class="sxs-lookup"><span data-stu-id="064b9-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="064b9-112">I <xref:Microsoft.Quantum.Diagnostics.DumpMachine> <xref:Microsoft.Quantum.Diagnostics.DumpRegister> richiamabili e indicano ai computer di destinazione di fornire informazioni di diagnostica su tutti i qubits attualmente allocati o su un registro specifico di qubits, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="064b9-112">The <xref:Microsoft.Quantum.Diagnostics.DumpMachine> and <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="064b9-113">Ogni computer di destinazione varia in base alle informazioni di diagnostica fornite in risposta a un'istruzione di dump.</span><span class="sxs-lookup"><span data-stu-id="064b9-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="064b9-114">Il computer di destinazione del [simulatore di stato completo](xref:microsoft.quantum.machines.full-state-simulator) , ad esempio, fornisce il programma host con il vettore di stato usato internamente per rappresentare un registro di qubits.</span><span class="sxs-lookup"><span data-stu-id="064b9-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="064b9-115">Per confronto, il computer di destinazione del [simulatore Toffoli](xref:microsoft.quantum.machines.toffoli-simulator) fornisce un solo bit classico per ogni qubit.</span><span class="sxs-lookup"><span data-stu-id="064b9-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="064b9-116">Per altre informazioni sull'output del [simulatore di stato completo](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` , vedere la sezione funzioni dump dell' [articolo test e debug](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="064b9-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="064b9-117">Fact e asserzioni</span><span class="sxs-lookup"><span data-stu-id="064b9-117">Facts and Assertions</span></span> ##

<span data-ttu-id="064b9-118">Come illustrato in [test e debug](xref:microsoft.quantum.guide.testingdebugging), una funzione o un'operazione con firma `Unit -> Unit` o `Unit => Unit` , rispettivamente, può essere contrassegnata come *unit test*.</span><span class="sxs-lookup"><span data-stu-id="064b9-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="064b9-119">Ogni unit test in genere è costituito da un piccolo programma Quantum, insieme a una o più condizioni che verificano la correttezza del programma.</span><span class="sxs-lookup"><span data-stu-id="064b9-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="064b9-120">Queste condizioni possono essere disponibili sotto forma di _Fact_, che controllano i valori degli input, o _asserzioni_, che controllano gli Stati di uno o più qubits passati come input.</span><span class="sxs-lookup"><span data-stu-id="064b9-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="064b9-121">Ad esempio, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` rappresenta il fatto matematico che $1 + 1 = $2, mentre `AssertQubit(One, qubit)` rappresenta la condizione che la misurazione `qubit` restituirà un oggetto `One` con certezza.</span><span class="sxs-lookup"><span data-stu-id="064b9-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="064b9-122">Nel primo caso, è possibile verificare la correttezza della condizione data solo i relativi valori, mentre nel secondo caso è necessario conoscere lo stato di qubit per valutare l'asserzione.</span><span class="sxs-lookup"><span data-stu-id="064b9-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="064b9-123">Le Q# librerie standard forniscono diverse funzioni per rappresentare i fatti, tra cui:</span><span class="sxs-lookup"><span data-stu-id="064b9-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:Microsoft.Quantum.Diagnostics.Fact>
- <xref:Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact>
- <xref:Microsoft.Quantum.Diagnostics.NearEqualityFactC>
- <xref:Microsoft.Quantum.Diagnostics.EqualityFactI>


### <a name="testing-qubit-states"></a><span data-ttu-id="064b9-124">Test di stati qubit</span><span class="sxs-lookup"><span data-stu-id="064b9-124">Testing Qubit States</span></span> ###

<span data-ttu-id="064b9-125">In pratica, le asserzioni si basano sul fatto che le simulazioni classiche dei meccanici quantistici non devono rispettare il [teorema di non clonazione](https://arxiv.org/abs/quant-ph/9607018), in modo da poter effettuare misurazioni e asserzioni non fisiche quando si usa un simulatore per il computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="064b9-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="064b9-126">Possiamo quindi testare singole operazioni su un simulatore classico prima di distribuirle su hardware.</span><span class="sxs-lookup"><span data-stu-id="064b9-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="064b9-127">Nei computer di destinazione che non consentono la valutazione delle asserzioni, le chiamate a <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> possono essere tranquillamente ignorate.</span><span class="sxs-lookup"><span data-stu-id="064b9-127">On target machines which do not allow evaluation of assertions, calls to <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> can be safely ignored.</span></span>

<span data-ttu-id="064b9-128">Più in generale, l' <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operazione asserisce che la misurazione del qubits specificato nella base di Pauli specificata avrà sempre il risultato specificato.</span><span class="sxs-lookup"><span data-stu-id="064b9-128">More generally, the <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="064b9-129">Se l'asserzione ha esito negativo, l'esecuzione termina chiamando `fail` con il messaggio specificato.</span><span class="sxs-lookup"><span data-stu-id="064b9-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="064b9-130">Per impostazione predefinita, questa operazione non è implementata; i simulatori che possono supportarlo devono fornire un'implementazione che esegua il controllo del runtime.</span><span class="sxs-lookup"><span data-stu-id="064b9-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="064b9-131">`AssertMeasurement` dispone della firma `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="064b9-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="064b9-132">Poiché `AssertMeasurement` è una funzione con una tupla vuota come tipo di output, nessun effetto chiamato `AssertMeasurement` è osservabile all'interno di un Q# programma.</span><span class="sxs-lookup"><span data-stu-id="064b9-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="064b9-133">La <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> funzione Operation asserisce che la misurazione del qubits specificato in base a Pauli specificato avrà il risultato specificato con la probabilità specificata, entro una certa tolleranza.</span><span class="sxs-lookup"><span data-stu-id="064b9-133">The <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="064b9-134">La tolleranza è additiva (ad esempio, `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="064b9-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="064b9-135">Se l'asserzione ha esito negativo, l'esecuzione termina chiamando `fail` con il messaggio specificato.</span><span class="sxs-lookup"><span data-stu-id="064b9-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="064b9-136">Per impostazione predefinita, questa operazione non è implementata; i simulatori che possono supportarlo devono fornire un'implementazione che esegua il controllo del runtime.</span><span class="sxs-lookup"><span data-stu-id="064b9-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="064b9-137">`AssertMeasurementProbability` dispone della firma `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="064b9-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="064b9-138">Il primo `Double` parametro fornisce la probabilità desiderata del risultato e la seconda la tolleranza.</span><span class="sxs-lookup"><span data-stu-id="064b9-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="064b9-139">È possibile eseguire altre operazioni oltre ad asserire una sola misurazione, usando il fatto che le informazioni classiche usate da un simulatore per rappresentare lo stato interno di un qubit sono suscettibili alla copia, in modo che non sia necessario eseguire effettivamente una misurazione per testare l'asserzione.</span><span class="sxs-lookup"><span data-stu-id="064b9-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="064b9-140">In particolare, ciò consente di ragionare su misurazioni *incompatibili* che non sarebbero possibili sull'hardware effettivo.</span><span class="sxs-lookup"><span data-stu-id="064b9-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="064b9-141">Si supponga che `P : Qubit => Unit` sia un'operazione progettata per preparare lo stato $ \ket{\psi} $ quando il relativo input è nello stato $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="064b9-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="064b9-142">Let $ \ket{\psi '} $ è lo stato effettivo preparato da `P` .</span><span class="sxs-lookup"><span data-stu-id="064b9-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="064b9-143">Quindi, $ \ket{\psi} = \ket{\psi '} $ If e solo se la misurazione di $ \ket{\psi '} $ nell'asse descritto da $ \ket{\psi} $ restituisce sempre `Zero` .</span><span class="sxs-lookup"><span data-stu-id="064b9-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="064b9-144">Ovvero \begin{align} \ket{\psi} = \ket{\psi '} \Text{if e only if} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="064b9-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="064b9-145">\end{align} usando le operazioni primitive definite nel preludio, è possibile eseguire direttamente una misurazione che restituisce `Zero` se $ \ket{\psi} $ è un autostato di uno degli operatori di Pauli.</span><span class="sxs-lookup"><span data-stu-id="064b9-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="064b9-146">L'operazione <xref:Microsoft.Quantum.Diagnostics.AssertQubit> fornisce un'abbreviazione particolarmente utile nel caso in cui si desideri testare l'asserzione $ \ket{\psi} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="064b9-146">The operation <xref:Microsoft.Quantum.Diagnostics.AssertQubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="064b9-147">Si tratta di un'operazione comune, ad esempio, quando è stato non calcolato per restituire ancilla qubits a $ \ket {0} $ prima di rilasciarli.</span><span class="sxs-lookup"><span data-stu-id="064b9-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="064b9-148">L'asserzione di $ \ket {0} $ è utile anche quando si vuole affermare che due `P` operazioni e la preparazione dello stato `Q` preparano lo stesso stato e quando `Q` supporta `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="064b9-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="064b9-149">In particolare,</span><span class="sxs-lookup"><span data-stu-id="064b9-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="064b9-150">In generale, tuttavia, potrebbe non essere possibile accedere alle asserzioni relative agli Stati che non coincidono con autostati degli operatori di Pauli.</span><span class="sxs-lookup"><span data-stu-id="064b9-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="064b9-151">Ad esempio, $ \ket{\psi} = (\ket {0} + e ^ {i \Pi/8} \ket {1} )/\sqrt {2} $ non è un autostato di alcun operatore Pauli, in modo da non poter usare <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> per determinare in modo univoco che uno stato $ \ket{\psi '} $ sia uguale a $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="064b9-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="064b9-152">È invece necessario scomporre l'asserzione $ \ket{\psi '} = \ket{\psi} $ in presupposti che possano essere testati direttamente usando le primitive supportate dal simulatore.</span><span class="sxs-lookup"><span data-stu-id="064b9-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="064b9-153">A tale scopo, fare in modo che $ \ket{\psi} = \Alpha \ket {0} + \beta \ket {1} $ per i numeri complessi $ \Alpha = a \_ r + a \_ i $ $ e $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="064b9-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="064b9-154">Si noti che questa espressione richiede quattro numeri reali $ \{ a \_ r, \_ i, b \_ r, b \_ i \} $ da specificare, perché ogni numero complesso può essere espresso come somma di una parte reale e immaginaria.</span><span class="sxs-lookup"><span data-stu-id="064b9-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="064b9-155">A causa della fase globale, tuttavia, è possibile scegliere $a \_ i = $0, in modo che siano necessari solo tre numeri reali per specificare in modo univoco un solo stato di qubit.</span><span class="sxs-lookup"><span data-stu-id="064b9-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="064b9-156">Pertanto, è necessario specificare tre asserzioni indipendenti l'una dall'altra per poter dichiarare lo stato previsto.</span><span class="sxs-lookup"><span data-stu-id="064b9-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="064b9-157">A tale scopo, è possibile trovare la probabilità di osservare `Zero` ogni misurazione di Pauli specificando $ \Alpha $ e $ \beta $ e asserindo ognuno in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="064b9-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="064b9-158">$X $, $y $ e $z $ be `Result` values rispettivamente per Pauli $X $, $Y $ e $Z $ measurements.</span><span class="sxs-lookup"><span data-stu-id="064b9-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="064b9-159">Quindi, usando la funzione di probabilità per le misurazioni Quantum, \begin{align} \Pr (x = \texttt{Zero} | \Alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \Alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{zero} | \Alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a \_ i ^ 2 + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="064b9-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="064b9-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="064b9-160">\end{align}</span></span>

<span data-ttu-id="064b9-161">L' <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operazione implementa queste asserzioni date le rappresentazioni di $ \Alpha $ e $ \beta $ come valori di tipo <xref:Microsoft.Quantum.Math.Complex> .</span><span class="sxs-lookup"><span data-stu-id="064b9-161">The <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:Microsoft.Quantum.Math.Complex>.</span></span>
<span data-ttu-id="064b9-162">Questa operazione è utile quando lo stato previsto può essere calcolato matematicamente.</span><span class="sxs-lookup"><span data-stu-id="064b9-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="064b9-163">Asserzione di uguaglianza di operazioni Quantum</span><span class="sxs-lookup"><span data-stu-id="064b9-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="064b9-164">Fino ad ora, ci siamo preoccupati per le operazioni di test mirate a preparare determinati stati.</span><span class="sxs-lookup"><span data-stu-id="064b9-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="064b9-165">Spesso, tuttavia, è interessante il modo in cui un'operazione agisce per gli input arbitrari anziché per un singolo input fisso.</span><span class="sxs-lookup"><span data-stu-id="064b9-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="064b9-166">Si supponga, ad esempio, che sia stata implementata un'operazione `U : ((Double, Qubit[]) => () : Adjoint)` corrispondente a una famiglia di operatori unitari $U (t) $ e che sia stato fornito un blocco esplicito `adjoint` anziché utilizzare `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="064b9-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="064b9-167">Potrebbe essere interessante affermare che $U ^ \dagger (t) = U (-t) $, come previsto se $t $ rappresenta un tempo di evoluzione.</span><span class="sxs-lookup"><span data-stu-id="064b9-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="064b9-168">In generale, esistono due strategie diverse che è possibile seguire per rendere l'asserzione che due operazioni `U` e agiscono in modo `V` identico.</span><span class="sxs-lookup"><span data-stu-id="064b9-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="064b9-169">In primo luogo, è possibile controllare che `U(target); (Adjoint V)(target);` ogni stato venga mantenuto in una determinata base.</span><span class="sxs-lookup"><span data-stu-id="064b9-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="064b9-170">In secondo luogo, è possibile controllare che la funzione `U(target); (Adjoint V)(target);` della metà di uno stato incastrato conserva l'errore.</span><span class="sxs-lookup"><span data-stu-id="064b9-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="064b9-171">Queste strategie sono implementate rispettivamente dalle operazioni canoniche <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> e da <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced> .</span><span class="sxs-lookup"><span data-stu-id="064b9-171">These strategies are implemented by the canon operations <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> and <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="064b9-172">L'asserzione a cui si fa riferimento descritta sopra funziona in base a [Choi-Jamiłkowski isomorfismo](https://en.wikipedia.org/wiki/Channel-state_duality), un framework matematico che mette in relazione le operazioni su $n $ qubits a stati aggrovigliati in $2n $ qubits.</span><span class="sxs-lookup"><span data-stu-id="064b9-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="064b9-173">In particolare, l'operazione di identità in $n $ qubits è rappresentata da $n $ copie dello stato di $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="064b9-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="064b9-174">L'operazione <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implementa questo isomorfismo, preparando uno stato che rappresenta un'operazione specificata.</span><span class="sxs-lookup"><span data-stu-id="064b9-174">The operation <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="064b9-175">Approssimativamente, queste strategie si distinguono da un compromesso di spazio-tempo.</span><span class="sxs-lookup"><span data-stu-id="064b9-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="064b9-176">L'iterazione di ogni stato di input richiede ulteriore tempo, mentre l'uso di un riferimento richiede l'archiviazione di qubits aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="064b9-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="064b9-177">Nei casi in cui un'operazione implementa un'operazione classica reversibile, in modo che sia interessato solo al suo comportamento sugli stati di base computazionale, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> verifica l'uguaglianza su questo set limitato di input.</span><span class="sxs-lookup"><span data-stu-id="064b9-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="064b9-178">L'iterazione sugli stati di input viene gestita dalle operazioni di enumerazione <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> e <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower> .</span><span class="sxs-lookup"><span data-stu-id="064b9-178">The iteration over input states is handled by the enumeration operations <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> and <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower>.</span></span>
> <span data-ttu-id="064b9-179">Queste operazioni sono utili più in generale per l'applicazione di un'operazione a ogni elemento del prodotto cartesiano tra due o più set.</span><span class="sxs-lookup"><span data-stu-id="064b9-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="064b9-180">In modo più critico, tuttavia, i due approcci verificano diverse proprietà delle operazioni sottoposte a verifica.</span><span class="sxs-lookup"><span data-stu-id="064b9-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="064b9-181">Poiché l'asserzione sul posto chiama ogni operazione più volte, una volta per ogni stato di input, eventuali scelte casuali e risultati di misurazione potrebbero cambiare tra le chiamate.</span><span class="sxs-lookup"><span data-stu-id="064b9-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="064b9-182">Al contrario, l'asserzione a cui si fa riferimento chiama ogni operazione una sola volta, in modo da verificare che le operazioni siano uguali *in un singolo colpo*.</span><span class="sxs-lookup"><span data-stu-id="064b9-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="064b9-183">Entrambi questi test sono utili per garantire la correttezza dei programmi Quantum.</span><span class="sxs-lookup"><span data-stu-id="064b9-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="064b9-184">Altre informazioni</span><span class="sxs-lookup"><span data-stu-id="064b9-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:Microsoft.Quantum.Diagnostics>
