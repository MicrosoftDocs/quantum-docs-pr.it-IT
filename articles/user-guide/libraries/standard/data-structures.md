---
title: Strutture dei dati nelle Q# librerie standard
description: Informazioni sulle strutture dei dati, i generatori di Oracle e i generatori dinamici nelle Q# librerie standard Microsoft.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: e9b593ba69ed41a9fb3c1298b5b945a4cbe43d5d
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858322"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="71f88-103">Strutture e modellazione dei dati</span><span class="sxs-lookup"><span data-stu-id="71f88-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="71f88-104">Strutture di dati classiche</span><span class="sxs-lookup"><span data-stu-id="71f88-104">Classical Data Structures</span></span> ##

<span data-ttu-id="71f88-105">Insieme ai tipi definiti dall'utente per la rappresentazione di concetti quantistici, la Canon fornisce anche operazioni, funzioni e tipi per lavorare con i dati classici usati nel controllo dei sistemi quantum.</span><span class="sxs-lookup"><span data-stu-id="71f88-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="71f88-106">Ad esempio, la <xref:Microsoft.Quantum.Arrays.Reversed> funzione accetta come input una matrice e restituisce la stessa matrice in ordine inverso.</span><span class="sxs-lookup"><span data-stu-id="71f88-106">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="71f88-107">Questa operazione può quindi essere usata in una matrice di tipo `Qubit[]` per evitare di dover applicare i controlli $ \operatorname{swap} $ non necessari quando si esegue la conversione tra rappresentazioni quantistiche di numeri interi.</span><span class="sxs-lookup"><span data-stu-id="71f88-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="71f88-108">Analogamente, nella sezione precedente è stato illustrato che i tipi del modulo `(Int, Int -> T)` possono essere utili per la rappresentazione di raccolte di accesso casuale, quindi la <xref:Microsoft.Quantum.Arrays.LookupFunction> funzione fornisce un modo pratico per costruire tali tipi dai tipi di matrice.</span><span class="sxs-lookup"><span data-stu-id="71f88-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:Microsoft.Quantum.Arrays.LookupFunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="71f88-109">Coppie</span><span class="sxs-lookup"><span data-stu-id="71f88-109">Pairs</span></span> ###

<span data-ttu-id="71f88-110">La canonica supporta la notazione in stile funzionale per le coppie, completando l'accesso alle tuple mediante la decostruzione:</span><span class="sxs-lookup"><span data-stu-id="71f88-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="71f88-111">Matrici</span><span class="sxs-lookup"><span data-stu-id="71f88-111">Arrays</span></span> ###

<span data-ttu-id="71f88-112">La canonica fornisce diverse funzioni per la modifica delle matrici.</span><span class="sxs-lookup"><span data-stu-id="71f88-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="71f88-113">Queste funzioni sono con parametri di tipo e possono quindi essere usate con matrici di qualsiasi Q# tipo.</span><span class="sxs-lookup"><span data-stu-id="71f88-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="71f88-114">Ad esempio, la <xref:Microsoft.Quantum.Arrays.Reversed> funzione restituisce una nuova matrice i cui elementi sono in ordine inverso rispetto al relativo input.</span><span class="sxs-lookup"><span data-stu-id="71f88-114">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="71f88-115">Questa operazione può essere utilizzata per modificare la modalità di rappresentazione di un registro Quantum durante la chiamata di operazioni:</span><span class="sxs-lookup"><span data-stu-id="71f88-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="71f88-116">Analogamente, la <xref:Microsoft.Quantum.Arrays.Subarray> funzione può essere usata per riordinare o usare subset degli elementi di una matrice:</span><span class="sxs-lookup"><span data-stu-id="71f88-116">Similarly, the <xref:Microsoft.Quantum.Arrays.Subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="71f88-117">In combinazione con il controllo di flusso, le funzioni di manipolazione di matrici come <xref:Microsoft.Quantum.Arrays.Zipped> possono fornire un modo efficace per esprimere i programmi Quantum:</span><span class="sxs-lookup"><span data-stu-id="71f88-117">When combined with flow control, array manipulation functions such as <xref:Microsoft.Quantum.Arrays.Zipped> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zipped([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="71f88-118">Oracoli</span><span class="sxs-lookup"><span data-stu-id="71f88-118">Oracles</span></span> ##

<span data-ttu-id="71f88-119">Nella letteratura relativa alla [fase di stima](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) e di [amplificazione dell'ampiezza](https://en.wikipedia.org/wiki/Amplitude_amplification) il concetto di Oracle viene visualizzato spesso.</span><span class="sxs-lookup"><span data-stu-id="71f88-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="71f88-120">Il termine Oracle fa riferimento a una subroutine Quantum che agisce su un set di qubits e restituisce la risposta come una fase.</span><span class="sxs-lookup"><span data-stu-id="71f88-120">Here the term oracle refers to a quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="71f88-121">Spesso questa subroutine può essere considerata come un input per un algoritmo Quantum che accetta Oracle, oltre ad altri parametri, e applica una serie di operazioni Quantum e che tratta una chiamata a questa subroutine Quantum come se fosse un controllo fondamentale.</span><span class="sxs-lookup"><span data-stu-id="71f88-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="71f88-122">Ovviamente, per implementare effettivamente l'algoritmo più ampio, è necessario fornire una scomposizione concreta del Oracle in controlli fondamentali, ma tale scomposizione non è necessaria per comprendere l'algoritmo che chiama Oracle.</span><span class="sxs-lookup"><span data-stu-id="71f88-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="71f88-123">In Q# questa astrazione viene rappresentata usando tali operazioni sono valori di prima classe, in modo che le operazioni possano essere passate alle implementazioni di algoritmi quantistici in modo nero.</span><span class="sxs-lookup"><span data-stu-id="71f88-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="71f88-124">I tipi definiti dall'utente, inoltre, vengono utilizzati per etichettare le diverse rappresentazioni Oracle in modo indipendente dai tipi, rendendo difficile la congestione accidentale di tipi diversi di operazioni black box.</span><span class="sxs-lookup"><span data-stu-id="71f88-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="71f88-125">Tali Oracle vengono visualizzati in diversi contesti, inclusi esempi noti, ad esempio gli algoritmi [di ricerca e di simulazione quantistica di Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) .</span><span class="sxs-lookup"><span data-stu-id="71f88-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="71f88-126">In questo articolo vengono illustrati i Oracle necessari solo per due applicazioni, ovvero l'amplificazione dell'ampiezza e la stima della fase.</span><span class="sxs-lookup"><span data-stu-id="71f88-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="71f88-127">Prima di procedere alla valutazione della fase, verranno illustrati prima i Oracle di amplificazione di ampiezza.</span><span class="sxs-lookup"><span data-stu-id="71f88-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="71f88-128">Oracle di amplificazione dell'ampiezza</span><span class="sxs-lookup"><span data-stu-id="71f88-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="71f88-129">L'algoritmo di amplificazione dell'ampiezza mira a eseguire una rotazione tra uno stato iniziale e uno stato finale applicando una sequenza di riflessioni dello stato.</span><span class="sxs-lookup"><span data-stu-id="71f88-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="71f88-130">Affinché l'algoritmo funzioni, è necessaria una specifica di entrambi questi Stati.</span><span class="sxs-lookup"><span data-stu-id="71f88-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="71f88-131">Queste specifiche sono fornite da due Oracle.</span><span class="sxs-lookup"><span data-stu-id="71f88-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="71f88-132">Questi Oracle funzionano suddividendo gli input in due spazi, un sottospazio "di destinazione" e un sottospazio "iniziale".</span><span class="sxs-lookup"><span data-stu-id="71f88-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="71f88-133">Gli Oracle identificano tali spazi subordinati, in modo analogo al modo in cui gli operatori Pauli identificano due spazi, applicando una fase $ \pm $1 a questi spazi.</span><span class="sxs-lookup"><span data-stu-id="71f88-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="71f88-134">La differenza principale consiste nel fatto che questi spazi non devono essere a metà spazi nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="71f88-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="71f88-135">Si noti anche che questi due sottospazi non si escludono in genere a vicenda: saranno presenti vettori che sono membri di entrambi gli spazi.</span><span class="sxs-lookup"><span data-stu-id="71f88-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="71f88-136">Se questa situazione non fosse vera, l'amplificazione dell'ampiezza non avrebbe alcun effetto, quindi è necessario che il sottospazio iniziale abbia una sovrapposizione diversa da zero con il sottospazio di destinazione.</span><span class="sxs-lookup"><span data-stu-id="71f88-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="71f88-137">Il primo Oracle necessario per l'amplificazione dell'ampiezza sarà $P \_ $0, definito in modo da avere l'azione seguente.</span><span class="sxs-lookup"><span data-stu-id="71f88-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="71f88-138">Per tutti gli Stati $ \ket{x} $ nel sottospazio "iniziale" $P \_ 0 \ket{x} =-\ket{x} $ e per tutti gli Stati $ \ket{y} $ che non sono presenti in questo sottospazio $P \_ 0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="71f88-139">Il Oracle che contrassegna il sottospazio di destinazione, $P _1 $, assume esattamente lo stesso formato.</span><span class="sxs-lookup"><span data-stu-id="71f88-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="71f88-140">Per tutti gli Stati $ \ket{x} $ nel sottospazio di destinazione (ad esempio, per tutti gli stati in cui si vuole che venga restituito l'algoritmo), $P _1 \ KET {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="71f88-141">Analogamente, per tutti gli Stati $ \ket{y} $ che non si trovano nel sottospazio di destinazione $P _1 \ KET {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="71f88-142">Queste due riflessioni vengono quindi combinate per formare un operatore che agisce su un singolo passaggio di amplificazione dell'ampiezza, $Q =-P_0 P_1 $, dove il segno meno generale è importante da considerare nelle applicazioni controllate.</span><span class="sxs-lookup"><span data-stu-id="71f88-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="71f88-143">L'amplificazione dell'ampiezza continua quindi con uno stato iniziale, $ \ket{\psi} $ che si trova nel sottospazio iniziale e quindi esegue $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="71f88-144">L'esecuzione di tale iterazione garantisce che se uno inizia con uno stato iniziale con sovrapposizione di $ \sin ^ 2 (\theta) $ con lo spazio contrassegnato, dopo $m iterazioni $ questa sovrapposizione diventa $ \sin ^ 2 ([2m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="71f88-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="71f88-145">Per questo motivo, in genere si vuole scegliere $m $ come parametro gratuito, in modo che $ [2m + 1] \theta = \ PI/2 $; Tuttavia, queste scelte rigide non sono altrettanto importanti per alcune forme di amplificazione dell'ampiezza, ad esempio l'amplificazione dell'ampiezza a punti fissi.</span><span class="sxs-lookup"><span data-stu-id="71f88-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="71f88-146">Questo processo consente di preparare uno stato nel sottospazio contrassegnato usando un numero minore di query per la funzione di contrassegno e la funzione di preparazione dello stato di quadratico in un dispositivo rigorosamente classico.</span><span class="sxs-lookup"><span data-stu-id="71f88-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="71f88-147">Questo è il motivo per cui l'amplificazione dell'ampiezza è un blocco predefinito significativo per molte applicazioni di quantum computing.</span><span class="sxs-lookup"><span data-stu-id="71f88-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="71f88-148">Per comprendere come usare l'algoritmo, è utile fornire un esempio che fornisce una costruzione di Oracle.</span><span class="sxs-lookup"><span data-stu-id="71f88-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="71f88-149">Si consiglia di eseguire l'algoritmo di Grover per le ricerche nel database in questa impostazione.</span><span class="sxs-lookup"><span data-stu-id="71f88-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="71f88-150">Nella ricerca di Grover l'obiettivo consiste nel trasformare lo stato $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket {0} $ in uno (potenzialmente) molti stati contrassegnati.</span><span class="sxs-lookup"><span data-stu-id="71f88-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="71f88-151">Per semplificare ulteriormente, esaminiamo il caso in cui l'unico stato contrassegnato è $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="71f88-152">Sono stati quindi progettati due Oracle: uno che contrassegna solo lo stato iniziale $ \ket{+} ^ {\otimes n} $ con un segno meno e un altro che contrassegna lo stato contrassegnato come $ \ket {0} $ con un segno meno.</span><span class="sxs-lookup"><span data-stu-id="71f88-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="71f88-153">Quest'ultimo può essere implementato usando l'operazione di elaborazione seguente, usando le operazioni del flusso di controllo in Canon:</span><span class="sxs-lookup"><span data-stu-id="71f88-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="71f88-154">Questo Oracle è quindi un caso speciale dell' <xref:Microsoft.Quantum.Canon.RAll1> operazione, che consente la rotazione di una fase arbitraria invece del caso di Reflection $ \Phi = \Pi $.</span><span class="sxs-lookup"><span data-stu-id="71f88-154">This oracle is then a special case of the <xref:Microsoft.Quantum.Canon.RAll1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="71f88-155">In questo caso, `RAll1` è simile all' <xref:Microsoft.Quantum.Intrinsic.R1> operazione di preludio, in quanto ruota circa $ \ket{11\cdots1} $ anziché lo stato qubit singolo $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-155">In this case, `RAll1` is similar to the <xref:Microsoft.Quantum.Intrinsic.R1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="71f88-156">Il Oracle che contrassegna il sottospazio iniziale può essere costruito in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="71f88-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="71f88-157">In pseudocodice:</span><span class="sxs-lookup"><span data-stu-id="71f88-157">In pseudocode:</span></span>

1. <span data-ttu-id="71f88-158">Applicare $H $ Gates a ogni qubit.</span><span class="sxs-lookup"><span data-stu-id="71f88-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="71f88-159">Applicare $X $ Gates a ogni qubit.</span><span class="sxs-lookup"><span data-stu-id="71f88-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="71f88-160">Applicare una $n-$1 controllata $Z $-Gate al $n ^ {\Text{TH}} $ qubit.</span><span class="sxs-lookup"><span data-stu-id="71f88-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="71f88-161">Applicare $X $ Gates a ogni qubit.</span><span class="sxs-lookup"><span data-stu-id="71f88-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="71f88-162">Applicare $H $ Gates a ogni qubit.</span><span class="sxs-lookup"><span data-stu-id="71f88-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="71f88-163">Questa volta viene inoltre illustrato l'utilizzo <xref:Microsoft.Quantum.Canon.ApplyWith> di insieme all' <xref:Microsoft.Quantum.Canon.RAll1> operazione descritta in precedenza:</span><span class="sxs-lookup"><span data-stu-id="71f88-163">This time, we also demonstrate using <xref:Microsoft.Quantum.Canon.ApplyWith> together with the <xref:Microsoft.Quantum.Canon.RAll1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="71f88-164">Possiamo quindi combinare questi due oracoli insieme per ruotare tra i due Stati e trasformare in modo deterministico $ \ket{+} ^ {\otimes n} $ in $ \ket {0} $ usando diversi livelli di Hadamard Gate proporzionali a $ \sqrt{2 ^ n} $ (ie $m \propto \sqrt{2 ^ n} $) rispetto ai livelli approssimativamente $2 ^ n $, necessari per preparare in modo non deterministico lo {0} stato di $ \ket $ preparando e misurando lo stato iniziale fino a quando non viene osservato il risultato $0 $.</span><span class="sxs-lookup"><span data-stu-id="71f88-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="71f88-165">Oracle di stima della fase</span><span class="sxs-lookup"><span data-stu-id="71f88-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="71f88-166">Per la stima della fase, i Oracle sono piuttosto più naturali.</span><span class="sxs-lookup"><span data-stu-id="71f88-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="71f88-167">Lo scopo della valutazione della fase è progettare una subroutine in grado di eseguire il campionamento dagli autovalori di una matrice unitaria.</span><span class="sxs-lookup"><span data-stu-id="71f88-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="71f88-168">Questo metodo è indispensabile nella simulazione quantistica perché per molti problemi fisici nella chimica e nell'analisi scientifica dei materiali questi autonomi offrono le energie di stato del sistema quantistica che forniscono informazioni utili sui diagrammi di fase di materiali e dinamiche di reazione per le molecole.</span><span class="sxs-lookup"><span data-stu-id="71f88-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="71f88-169">Ogni versione della valutazione della fase richiede un unità di input.</span><span class="sxs-lookup"><span data-stu-id="71f88-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="71f88-170">Questo unitario è comunemente descritto da uno dei due tipi di Oracle.</span><span class="sxs-lookup"><span data-stu-id="71f88-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="71f88-171">Entrambi i tipi di Oracle descritti di seguito sono trattati negli esempi.</span><span class="sxs-lookup"><span data-stu-id="71f88-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="71f88-172">Per ulteriori informazioni sugli Oracle con query continue, vedere l'esempio [ **PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="71f88-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="71f88-173">Per ulteriori informazioni sugli Oracle con query discrete, vedere l' [esempio **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="71f88-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="71f88-174">Il primo tipo di Oracle, che viene chiamato una query discreta Oracle e che rappresenta con il tipo definito dall'utente <xref:Microsoft.Quantum.Oracles.DiscreteOracle> , comporta semplicemente una matrice unitaria.</span><span class="sxs-lookup"><span data-stu-id="71f88-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:Microsoft.Quantum.Oracles.DiscreteOracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="71f88-175">Se $U $ è l'unitario i cui autonomi si desidera stimare, Oracle per $U $ è semplicemente uno stato di una subroutine che implementa $U $.</span><span class="sxs-lookup"><span data-stu-id="71f88-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="71f88-176">Ad esempio, è possibile che si prenda $U $ come Oracle $Q $ defined per la stima dell'ampiezza.</span><span class="sxs-lookup"><span data-stu-id="71f88-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="71f88-177">Gli autovalori di questa matrice possono essere usati per stimare la sovrapposizione tra gli stati iniziale e di destinazione, $ \sin ^ 2 (\theta) $, usando quadratico un minor numero di campioni di quelli necessari altrimenti.</span><span class="sxs-lookup"><span data-stu-id="71f88-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="71f88-178">In questo modo si ottiene l'applicazione della valutazione della fase usando l'Oracle di Grover $Q $ come input il moniker della stima dell'ampiezza.</span><span class="sxs-lookup"><span data-stu-id="71f88-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="71f88-179">Un'altra applicazione comune, ampiamente utilizzata nella metrologia quantistica, comporta la stima di un angolo di rotazione ridotto.</span><span class="sxs-lookup"><span data-stu-id="71f88-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="71f88-180">In altre parole, si desidera stimare $ \theta $ per un controllo di rotazione sconosciuto nel formato $R _z (\theta) $.</span><span class="sxs-lookup"><span data-stu-id="71f88-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="71f88-181">In questi casi, la subroutine con cui si interagirà per apprendere questo valore fisso di $ \theta $ per il Gate è $ $ \begin{align} U & = R_z (\theta) \\ \\ & = \begin{Bmatrix} e ^ {-i \theta/2} & 0 \\ \\ 0 & e ^ {i \ Theta/2} \end{Bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="71f88-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="71f88-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="71f88-182">\end{align} $$</span></span>

<span data-ttu-id="71f88-183">Il secondo tipo di Oracle usato nella stima della fase è la query continua Oracle, rappresentata dal <xref:Microsoft.Quantum.Oracles.ContinuousOracle> tipo.</span><span class="sxs-lookup"><span data-stu-id="71f88-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:Microsoft.Quantum.Oracles.ContinuousOracle> type.</span></span>
<span data-ttu-id="71f88-184">Una query continua Oracle per la stima della fase assume il formato $U (t) $ dove $t $ è un numero reale noto in modo classico.</span><span class="sxs-lookup"><span data-stu-id="71f88-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="71f88-185">Se si lascia che $U $ sia un unitario fisso, l'Oracle della query continua assume il formato $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="71f88-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="71f88-186">Questo consente di eseguire query su matrici quali $ \sqrt{U} $, che non possono essere implementate direttamente nel modello di query discreto.</span><span class="sxs-lookup"><span data-stu-id="71f88-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="71f88-187">Questo tipo di Oracle è utile quando non si esegue il sondaggio di un particolare gruppo, ma si desidera apprendere le proprietà del generatore dell'unità.</span><span class="sxs-lookup"><span data-stu-id="71f88-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="71f88-188">Nella simulazione Quantum dinamica, ad esempio, l'obiettivo è quello di definire circuiti Quantum che siano strettamente approssimativi $U (t) = e ^ {-i H t} $ per una matrice Hermitiane $H $ ed Evolution Time $t $.</span><span class="sxs-lookup"><span data-stu-id="71f88-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="71f88-189">Gli autovalori di $U (t) $ sono direttamente correlati agli autovalori di $H $.</span><span class="sxs-lookup"><span data-stu-id="71f88-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="71f88-190">Per verificarlo, si consideri un autovettore di $H $: $H \ket{E} = E\ket {E} $, quindi è facile vedere dalla definizione della serie Power della matrice esponenziale che $U (t) \ket{E} = e ^ {i\phi} \ KET {E} = e ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="71f88-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="71f88-191">In questo modo, la stima del eigenphase di $U (t) $ restituisce il autovalore $E $ presumendo che autovettore $ \ket{E} $ sia l'input nell'algoritmo di stima della fase.</span><span class="sxs-lookup"><span data-stu-id="71f88-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="71f88-192">Tuttavia, in questo caso il valore $t $ può essere scelto a discrezione dell'utente, perché per qualsiasi valore sufficientemente piccolo di $t $ il autovalore $E $ può essere invertito in modo univoco tramite $E =-\ Phi/t $.</span><span class="sxs-lookup"><span data-stu-id="71f88-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="71f88-193">Poiché i metodi di simulazione Quantum offrono la possibilità di eseguire un'evoluzione frazionaria, questo concede agli algoritmi di stima della fase una maggiore libertà durante l'esecuzione di query sull'unità, in particolare quando il modello di query discrete consente solo unitaries nel formato $U ^ j $ a applicato per Integer $j $ The Continuous query Oracle consente di approssimarsi a unitaries nel formato $U ^ t $ per qualsiasi $t valore reale</span><span class="sxs-lookup"><span data-stu-id="71f88-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="71f88-194">Questo è importante per comprimere tutte le ultime once di efficienza al di fuori degli algoritmi di stima della fase perché consente di scegliere con precisione l'esperimento che fornirebbe la maggior parte delle informazioni su $E $; mentre i metodi basati su query discrete devono effettuare l'operazione con la compromissione scegliendo il numero intero migliore di query nell'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="71f88-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="71f88-195">Come esempio concreto, si consideri il problema della stima non dell'angolo di rotazione di un controllo, ma della frequenza di elaborazione di un sistema Quantum rotante.</span><span class="sxs-lookup"><span data-stu-id="71f88-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="71f88-196">L'unitario che descrive tali Dynamics Quantum è $U (t) = R_z (2 \ Omega t) $ per il tempo di Evolution $t $ e la frequenza sconosciuta $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="71f88-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="71f88-197">In questo contesto, è possibile simulare $U (t) $ per qualsiasi $t $ utilizzando un singolo $R _z $ Gate e, di conseguenza, non è necessario limitarsi solo alle query discrete per l'unità.</span><span class="sxs-lookup"><span data-stu-id="71f88-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="71f88-198">Un modello continuo di questo tipo ha anche la proprietà che le frequenze maggiori di $2 \ PI $ possono essere apprese dai processi di stima della fase che usano le query continue perché le informazioni sulle fasi che verrebbero altrimenti mascherate dai tagli di rami della funzione logaritmo possono essere rivelate dai risultati di esperimenti eseguiti su valori non commisurati di $t $.</span><span class="sxs-lookup"><span data-stu-id="71f88-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="71f88-199">Per risolvere i problemi, ad esempio i modelli di query continua per la valutazione della fase, Oracle non solo è appropriato ma è preferibile anche al modello di query discreto.</span><span class="sxs-lookup"><span data-stu-id="71f88-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="71f88-200">Per questo motivo, Q# presenta funzionalità per entrambe le forme di query e consente all'utente di decidere in base a un algoritmo di stima della fase per adattarsi alle proprie esigenze e al tipo di Oracle disponibile.</span><span class="sxs-lookup"><span data-stu-id="71f88-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="71f88-201">Modellazione dinamica del generatore</span><span class="sxs-lookup"><span data-stu-id="71f88-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="71f88-202">Generatori di Time-Evolution descrive il modo in cui gli Stati si evolvono nel tempo.</span><span class="sxs-lookup"><span data-stu-id="71f88-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="71f88-203">Ad esempio, le dinamiche di uno stato quantico $ \ket{\psi} $ sono regolate dall'equazione Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ con una matrice Hermitiane $H $, nota come hamiltoniana, come il generatore di movimento.</span><span class="sxs-lookup"><span data-stu-id="71f88-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="71f88-204">Dato uno stato iniziale $ \ket{\psi (0)} $ at time $t = $0, la soluzione formale a questa equazione al momento $t $ può essere, in linea di principio, scritta $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $ in cui l'esponenziale della matrice $U (t) = e ^ {-i H t} $ è noto come operatore di evoluzione temporale unitario.</span><span class="sxs-lookup"><span data-stu-id="71f88-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="71f88-205">Sebbene ci si concentri sui generatori di questo modulo nel seguente modo, viene evidenziato che il concetto si applica in modo più ampio, ad esempio alla simulazione di sistemi quantistici aperti, o a equazioni differenziali più astratte.</span><span class="sxs-lookup"><span data-stu-id="71f88-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="71f88-206">Uno degli obiettivi principali della simulazione dinamica consiste nell'implementare l'operatore Time-Evolution in uno stato quantico codificato in qubits di un computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="71f88-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="71f88-207">In molti casi, l'Hamiltoniana può essere suddivisa in una somma di alcune $d $ più semplici termini</span><span class="sxs-lookup"><span data-stu-id="71f88-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="71f88-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="71f88-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="71f88-209">laddove l'evoluzione del tempo per ogni termine è facile da implementare in un computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="71f88-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="71f88-210">Se, ad esempio, $H _j $ è un $X Pauli _1X_2 operatore $ che agisce sul primo e il secondo elemento del registro qubit `qubits` , il time-Evolution per ogni tempo $t $ può essere implementato semplicemente chiamando l'operazione con la `Exp([PauliX,PauliX], t, qubits[1..2])` firma `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="71f88-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="71f88-211">Come illustrato più avanti nella simulazione di hamiltoniana, una soluzione prevede di approssimarsi all'evoluzione del tempo per $H $ con una sequenza di operazioni più semplici</span><span class="sxs-lookup"><span data-stu-id="71f88-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="71f88-212">$ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="71f88-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="71f88-213">dove il valore integer $r > $0 controlla l'errore di approssimazione.</span><span class="sxs-lookup"><span data-stu-id="71f88-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="71f88-214">La libreria di modellazione generatore dinamica fornisce un Framework per codificare sistematicamente i generatori complicati in termini di generatori più semplici.</span><span class="sxs-lookup"><span data-stu-id="71f88-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="71f88-215">Una descrizione di questo tipo può quindi essere passata, ad esempio, dalla libreria di simulazione per implementare l'evoluzione del tempo in base a un algoritmo di simulazione scelto, con molti dettagli gestiti automaticamente.</span><span class="sxs-lookup"><span data-stu-id="71f88-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="71f88-216">La libreria del generatore dinamica descritta di seguito è illustrata negli esempi.</span><span class="sxs-lookup"><span data-stu-id="71f88-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="71f88-217">Per un esempio basato sul modello Ising, vedere l' [esempio **IsingGenerators**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="71f88-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="71f88-218">Per un esempio basato su idrogeno molecolare, vedere gli esempi di [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) e [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) .</span><span class="sxs-lookup"><span data-stu-id="71f88-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="71f88-219">Descrizione completa di un generatore</span><span class="sxs-lookup"><span data-stu-id="71f88-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="71f88-220">Al livello principale, una descrizione completa di un'Hamiltoniana è contenuta nel `EvolutionGenerator` tipo definito dall'utente con due componenti:</span><span class="sxs-lookup"><span data-stu-id="71f88-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="71f88-221">Il `GeneratorSystem` tipo definito dall'utente è una descrizione classica dell'hamiltoniana.</span><span class="sxs-lookup"><span data-stu-id="71f88-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="71f88-222">Il primo elemento `Int` della tupla archivia il numero di termini $d $ nell'Hamiltoniana e il secondo elemento `(Int -> GeneratorIndex)` è una funzione che esegue il mapping di un indice Integer in $ \{ 0, 1,..., d-1 \} $ a un `GeneratorIndex` tipo definito dall'utente che identifica in modo univoco ogni termine primitivo nell'Hamiltoniana.</span><span class="sxs-lookup"><span data-stu-id="71f88-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="71f88-223">Si noti che, esprimendo la raccolta di termini nell'Hamiltoniana come funzione anziché come matrice `GeneratorIndex[]` , questo consente un calcolo immediato di, `GeneratorIndex` che risulta particolarmente utile quando si descrive hamiltonians con un numero elevato di termini.</span><span class="sxs-lookup"><span data-stu-id="71f88-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="71f88-224">Fondamentalmente, non viene imposta una convenzione sui termini primitivi identificati da `GeneratorIndex` sono facili da simulare.</span><span class="sxs-lookup"><span data-stu-id="71f88-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="71f88-225">Ad esempio, i termini primitivi potrebbero essere operatori di Pauli come descritto in precedenza, ma possono anche essere fermioniche annientamento e operatori di creazione usati comunemente nella simulazione della chimica quantistica.</span><span class="sxs-lookup"><span data-stu-id="71f88-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="71f88-226">Di per sé, un oggetto `GeneratorIndex` non ha alcun significato perché non descrive il modo in cui l'evoluzione del tempo per il termine a cui fa riferimento può essere implementata come un circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="71f88-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="71f88-227">Questo problema viene risolto specificando un `EvolutionSet` tipo definito dall'utente che esegue il mapping di qualsiasi oggetto `GeneratorIndex` , disegnato da un set canonico, a un operatore unitario, `EvolutionUnitary` , espresso come un circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="71f88-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="71f88-228">`EvolutionSet`Definisce la convenzione di struttura di un oggetto `GeneratorIndex` e definisce anche il set di possibili `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="71f88-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="71f88-229">Generatori di operatori Pauli</span><span class="sxs-lookup"><span data-stu-id="71f88-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="71f88-230">Un esempio concreto e utile di generatori è costituito da hamiltonians che sono una somma di operatori Pauli, ognuno dei quali può avere un coefficiente diverso.</span><span class="sxs-lookup"><span data-stu-id="71f88-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="71f88-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $ dove ogni $ \hat H_j $ viene ora disegnato dal gruppo Pauli.</span><span class="sxs-lookup"><span data-stu-id="71f88-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="71f88-232">Per tali sistemi, viene fornito l'oggetto `PauliEvolutionSet()` di tipo `EvolutionSet` che definisce una convenzione per il modo in cui un elemento del gruppo Pauli e un coefficiente possono essere identificati da un oggetto `GeneratorIndex` , che presenta la firma seguente.</span><span class="sxs-lookup"><span data-stu-id="71f88-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="71f88-233">Nella codifica, il primo parametro `Int[]` specifica una stringa di Pauli, dove $ \Hat I\rightarrow $0, $ \Hat X\rightarrow $1, $ \Hat Y\rightarrow $2 e $ \Hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="71f88-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="71f88-234">Il secondo parametro `Double[]` archivia il coefficiente della stringa Pauli nell'Hamiltoniana.</span><span class="sxs-lookup"><span data-stu-id="71f88-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="71f88-235">Si noti che viene usato solo il primo elemento della matrice.</span><span class="sxs-lookup"><span data-stu-id="71f88-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="71f88-236">Il terzo parametro `Int[]` indicizza il qubits su cui agisce questa stringa di Pauli e non deve avere elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="71f88-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="71f88-237">Pertanto, il termine hamiltoniana $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ può essere rappresentato come</span><span class="sxs-lookup"><span data-stu-id="71f88-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="71f88-238">`PauliEvolutionSet()`È una funzione che esegue il mapping di qualsiasi `GeneratorIndex` di questo form a un oggetto `EvolutionUnitary` con la firma seguente.</span><span class="sxs-lookup"><span data-stu-id="71f88-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="71f88-239">Il primo parametro rappresenta un intervallo di tempo, che verrà moltiplicato per il coefficiente in `GeneratorIndex` , dell'evoluzione unitaria.</span><span class="sxs-lookup"><span data-stu-id="71f88-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="71f88-240">Il secondo parametro è il registro qubit su cui agisce l'unità.</span><span class="sxs-lookup"><span data-stu-id="71f88-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="71f88-241">Generatori di Time-Dependent</span><span class="sxs-lookup"><span data-stu-id="71f88-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="71f88-242">In molti casi, si è interessati anche alla modellazione di generatori dipendenti dal tempo, come potrebbe verificarsi nell'equazione Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $ dove il generatore $ \hat H (t) $ ora dipende dal tempo.</span><span class="sxs-lookup"><span data-stu-id="71f88-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="71f88-243">L'estensione dai generatori di tempo indipendenti sopra a questo caso è semplice.</span><span class="sxs-lookup"><span data-stu-id="71f88-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="71f88-244">Invece di avere un oggetto fisso che `GeneratorSystem` descrive l'Hamiltoniana per tutti gli orari $t $, abbiamo invece il `GeneratorSystemTimeDependent` tipo definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="71f88-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="71f88-245">Il primo parametro è un parametro di pianificazione continua $s \In [0, 1] $ e le funzioni di questo tipo restituiscono un oggetto `GeneratorSystem` per tale pianificazione.</span><span class="sxs-lookup"><span data-stu-id="71f88-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="71f88-246">Si noti che il parametro Schedule può essere correlato in modo lineare al parametro del tempo fisico, ad esempio $s = t/T $, per un tempo totale di simulazione $T $.</span><span class="sxs-lookup"><span data-stu-id="71f88-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="71f88-247">In generale, tuttavia, questa situazione non è necessaria.</span><span class="sxs-lookup"><span data-stu-id="71f88-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="71f88-248">Analogamente, una descrizione completa di questo generatore richiede un oggetto `EvolutionSet` , quindi viene `EvolutionSchedule` definito un tipo definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="71f88-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
