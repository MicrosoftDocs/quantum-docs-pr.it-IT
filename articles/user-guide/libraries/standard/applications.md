---
title: 'Applicazioni nelle :::no-loc(Q#)::: librerie standard'
description: 'Informazioni su due applicazioni fondamentali in quantum computing: simulazione Hamiltoniana e algoritmo di ricerca di Shor.'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 5a29dcc74c638cb8ecbeb1f924d0e50d40d19f66
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692168"
---
# <a name="applications"></a><span data-ttu-id="e3af6-103">Applicazioni</span><span class="sxs-lookup"><span data-stu-id="e3af6-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="e3af6-104">Simulazione hamiltoniana</span><span class="sxs-lookup"><span data-stu-id="e3af6-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="e3af6-105">La simulazione dei sistemi quantistici è una delle applicazioni più interessanti del calcolo quantistico.</span><span class="sxs-lookup"><span data-stu-id="e3af6-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="e3af6-106">In un computer classico, la difficoltà di simulare la meccanica quantistica, in generale, è scalabile con la dimensione $N $ della relativa rappresentazione di vettori di stato.</span><span class="sxs-lookup"><span data-stu-id="e3af6-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="e3af6-107">Poiché questa rappresentazione cresce in modo esponenziale con il numero di $n $ qubits $N = 2 ^ n $, una caratteristica nota anche come [Curse of dimensionance](xref:microsoft.quantum.concepts.multiple-qubits), la simulazione quantistica sull'hardware classico è intratta.</span><span class="sxs-lookup"><span data-stu-id="e3af6-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="e3af6-108">Tuttavia, la situazione può essere molto diversa nell'hardware del quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="e3af6-109">La variante più comune della simulazione quantistica è detta problema di simulazione hamiltoniana indipendente dal tempo.</span><span class="sxs-lookup"><span data-stu-id="e3af6-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="e3af6-110">Ne viene fornita una con una descrizione dell'Hamiltoniana del sistema $H $, che è una matrice Hermitiane e di uno stato quantum iniziale $ \ket{\psi (0)} $ codificato in base a $n $ qubits in un computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="e3af6-111">Poiché gli Stati Quantum nei sistemi chiusi si evolvono nell'equazione Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ lo scopo è quello di implementare l'operatore Time-Evolution $U (t) = e ^ {-iHt} $ a un certo tempo fisso $t $, dove $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ risolve l'equazione Schrödinger.</span><span class="sxs-lookup"><span data-stu-id="e3af6-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="e3af6-112">Analogamente, il problema della simulazione hamiltoniana dipendente dal tempo risolve la stessa equazione, ma con $H (t) $ Now una funzione di tempo.</span><span class="sxs-lookup"><span data-stu-id="e3af6-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="e3af6-113">La simulazione hamiltoniana è un componente fondamentale di molti altri problemi di simulazione quantistica e le soluzioni al problema della simulazione hamiltoniana sono algoritmi che descrivono una sequenza di controlli Quantum primitivi per la sintesi di un elemento unitario approssimativo $ \tilde{U} $ con errore $ \\ | \tilde{U}-U (t) \\ | \Le \epsilon $ nella [norma spettrale](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="e3af6-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="e3af6-114">La complessità di questi algoritmi dipende molto fortemente dal modo in cui una descrizione dell'Hamiltoniana di interesse viene resa accessibile da un computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="e3af6-115">Nel caso peggiore, ad esempio, se $H $ che agisce su $n $ qubits venisse fornito come un elenco di $2 ^ n \times 2 ^ n $ numeri, uno per ogni elemento della matrice, semplicemente leggendo i dati sarebbe già necessario un tempo esponenziale.</span><span class="sxs-lookup"><span data-stu-id="e3af6-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="e3af6-116">Nel migliore dei casi, è possibile che si presupponga l'accesso a un unitario nero che $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ in modo banale risolve il problema.</span><span class="sxs-lookup"><span data-stu-id="e3af6-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="e3af6-117">Nessuno di questi modelli di input è particolarmente interessante, ovvero il primo, perché non è migliore degli approcci classici e il secondo come la scatola nera nasconde la complessità del controllo primitivo della relativa implementazione, che può essere esponenziale nel numero di qubits.</span><span class="sxs-lookup"><span data-stu-id="e3af6-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="e3af6-118">Descrizioni di hamiltonians</span><span class="sxs-lookup"><span data-stu-id="e3af6-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="e3af6-119">Sono pertanto necessari presupposti aggiuntivi del formato dell'input.</span><span class="sxs-lookup"><span data-stu-id="e3af6-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="e3af6-120">Un equilibrio ottimale tra i modelli di input è sufficientemente descrittivo per includere hamiltonians interessanti, ad esempio quelli per i sistemi fisici realistici o problemi di calcolo interessanti, e modelli di input sufficientemente restrittivi per essere implementabili in modo efficiente in un computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="e3af6-121">In letteratura è possibile trovare una varietà di modelli di input non semplici che variano dal quantum al classico.</span><span class="sxs-lookup"><span data-stu-id="e3af6-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="e3af6-122">Come esempi di modelli di input Quantum, la [simulazione hamiltoniana basata sul campione](http://www.nature.com/articles/s41534-017-0013-7) presuppone l'accesso nero alle operazioni Quantum che producono copie di una matrice di densità $ \rho $, che vengono adottate come hamiltoniana $H $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="e3af6-123">Nel [modello di accesso unitario](https://arxiv.org/abs/1202.5822) si presuppone che l'Hamiltoniana venga invece suddivisa in una somma di unitaries $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j, \end{align} $ $ dove $a \_ j>$0 sono coefficienti e $ \hat{U} \_ j $ sono unitaries.</span><span class="sxs-lookup"><span data-stu-id="e3af6-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="e3af6-124">Si presuppone quindi che uno disponga di un accesso nero all'unità Oracle $V = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $ che seleziona il $ \hat{U} \_ j $ desiderato, e Oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ Sum ^ {d-1} \_ {k = 0} \Alpha \_ j} \ket{j} $ che creano uno stato quantico che codifica questi coefficienti.</span><span class="sxs-lookup"><span data-stu-id="e3af6-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="e3af6-125">Nel caso della simulazione di un' [Hamiltoniana di tipo sparse](https://arxiv.org/abs/quant-ph/0301023), si presuppone che l'Hamiltoniana sia una matrice di tipo sparse con un solo elemento $d = \mathcal{O} (\Text{POLYLOG} (N)) $ diverso da zero in ogni riga.</span><span class="sxs-lookup"><span data-stu-id="e3af6-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="e3af6-126">Inoltre, si presuppone l'esistenza di circuiti Quantum efficienti che restituiscono la posizione di questi elementi diversi da zero, nonché i relativi valori.</span><span class="sxs-lookup"><span data-stu-id="e3af6-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="e3af6-127">La complessità degli [algoritmi di simulazione hamiltoniana](xref:microsoft.quantum.more-information) viene valutata in termini di numero di query su queste caselle nere e la complessità del controllo primitivo dipende quindi molto dalla difficoltà di implementazione di queste caselle nere.</span><span class="sxs-lookup"><span data-stu-id="e3af6-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="e3af6-128">La notazione Big-O viene comunemente usata per descrivere il ridimensionamento della complessità degli algoritmi.</span><span class="sxs-lookup"><span data-stu-id="e3af6-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="e3af6-129">Date due funzioni reali $f, g $, l'espressione $g (x) = \mathcal{O} (f (x)) $ significa che esiste una costante positiva assoluta $x \_ 0, c>$0 in modo che $g (x) \Le c f (x) $ per tutti $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="e3af6-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="e3af6-130">Nella maggior parte delle applicazioni pratiche che devono essere implementate in un computer Quantum, queste caselle nere devono essere implementabili in modo efficiente, ovvero con $ \mathcal{O} (\Text{POLYLOG} (N)) $ primitive Quantum Gates.</span><span class="sxs-lookup"><span data-stu-id="e3af6-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="e3af6-131">In modo più efficiente, simulable hamiltonians deve avere una descrizione abbastanza semplice e di tipo sparse.</span><span class="sxs-lookup"><span data-stu-id="e3af6-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="e3af6-132">In una formula di questo tipo si presuppone che l'Hamiltoniana venga suddivisa in una somma di Hermitiane parti $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="e3af6-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="e3af6-133">\end{align} $ $, inoltre, si presuppone che ogni parte, un'Hamiltoniana $H \_ j $, sia facile da simulare.</span><span class="sxs-lookup"><span data-stu-id="e3af6-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="e3af6-134">Ciò significa che l'unità $e ^ {-iH \_ j t} $ per ogni ora $t $ può essere implementata esattamente tramite $ \mathcal{O} (1) $ primitive Quantum Gates.</span><span class="sxs-lookup"><span data-stu-id="e3af6-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="e3af6-135">Questa situazione si verifica, ad esempio, nel caso speciale in cui ogni $H \_ j $ sono operatori locali di Pauli, vale a dire che si tratta di prodotti tensori di $ \mathcal{O} (1) $ non-Identity Pauli Operators che agiscono su qubits spaziali.</span><span class="sxs-lookup"><span data-stu-id="e3af6-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="e3af6-136">Questo modello è particolarmente applicabile ai sistemi fisici con interazione vincolata e locale, in quanto il numero di termini è $d = \mathcal{O} (\Text{POLYLOG} (N)) $ e può essere chiaramente scritto, ovvero una descrizione classica, in tempo polinomi.</span><span class="sxs-lookup"><span data-stu-id="e3af6-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="e3af6-137">Hamiltonians che si decompongono in una somma di parti possono essere descritte utilizzando la libreria di rappresentazione dinamica del generatore.</span><span class="sxs-lookup"><span data-stu-id="e3af6-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="e3af6-138">Per ulteriori informazioni, vedere la sezione relativa alla rappresentazione dinamica del generatore in [strutture di dati](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="e3af6-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="e3af6-139">Algoritmi di simulazione</span><span class="sxs-lookup"><span data-stu-id="e3af6-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="e3af6-140">Un algoritmo di simulazione quantistica converte una determinata descrizione di un'Hamiltoniana in una sequenza di controlli Quantum primitivi che, nel suo complesso, hanno un'evoluzione approssimativa del tempo in base all'Hamiltoniana.</span><span class="sxs-lookup"><span data-stu-id="e3af6-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="e3af6-141">Nel caso speciale in cui l'Hamiltoniana si scompone in una somma di parti hermitiane, il Trotter-Suzuki scomposizione è un algoritmo particolarmente semplice e intuitivo per la simulazione di hamiltonians che si decompongono in una somma di componenti Hermitiane.</span><span class="sxs-lookup"><span data-stu-id="e3af6-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="e3af6-142">Un integratore di questo gruppo, ad esempio, si avvicina a $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ utilizzando un prodotto di $r d $ termini.</span><span class="sxs-lookup"><span data-stu-id="e3af6-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="e3af6-143">Negli esempi sono incluse le applicazioni dell'algoritmo di simulazione Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="e3af6-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="e3af6-144">Per il modello Ising usando solo le operazioni intrinseche fornite da ogni computer di destinazione, vedere l' [esempio **SimpleIsing**](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="e3af6-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="e3af6-145">Per il modello Ising usando la struttura di controllo della libreria Trotter-Suzuki, vedere l' [esempio **IsingTrotter**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="e3af6-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="e3af6-146">Per l'idrogeno molecolare usando la struttura di controllo della libreria Trotter-Suzuki, vedere l'esempio di [ **simulazione H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="e3af6-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="e3af6-147">In molti casi, si desidera implementare l'algoritmo di simulazione, ma non sono interessati ai dettagli della relativa implementazione.</span><span class="sxs-lookup"><span data-stu-id="e3af6-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="e3af6-148">Ad esempio, l'integratore di secondo ordine si avvicina a $ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/2R} e ^ {-IH \_ 1 t/2R} \cdots e ^ {-IH \_ {d-1} t/2R} e ^ {-IH \_ {d-1} t/2R} \cdots e ^ {-IH \_ 1 t/2R} e ^ {-IH \_ 0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ usando un prodotto di $2RD $ termini.</span><span class="sxs-lookup"><span data-stu-id="e3af6-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="e3af6-149">Gli ordini di dimensioni maggiori comporteranno un numero ancora maggiore di termini e varianti ottimizzate potrebbero richiedere ordinamenti altamente non semplici sugli esponenziali.</span><span class="sxs-lookup"><span data-stu-id="e3af6-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="e3af6-150">Altri algoritmi avanzati possono anche comportare l'uso di ancilla qubits nei passaggi intermedi.</span><span class="sxs-lookup"><span data-stu-id="e3af6-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="e3af6-151">Quindi, gli algoritmi di simulazione vengono impacchettati in Canon come tipo definito dall'utente</span><span class="sxs-lookup"><span data-stu-id="e3af6-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="e3af6-152">Il primo parametro `Double` è l'ora della simulazione, il secondo parametro `EvolutionGenerator` , illustrato nella sezione relativa alla rappresentazione dinamica del generatore di [strutture di dati](xref:microsoft.quantum.libraries.data-structures), è una descrizione classica di un'Hamiltoniana indipendente dal tempo, in cui vengono fornite istruzioni su come ogni termine nell'Hamiltoniana può essere simulato da un circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="e3af6-153">I tipi di questo form approssimano l'operazione unitaria $e ^ {-iHt} $ sul terzo parametro `Qubit[]` , ovvero il registro che archivia lo stato del quantum del sistema simulato.</span><span class="sxs-lookup"><span data-stu-id="e3af6-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="e3af6-154">Analogamente, per il caso dipendente dal tempo, viene definito un tipo definito dall'utente con un `EvolutionSchedule` tipo, ovvero una descrizione classica di un'Hamiltoniana dipendente dal tempo.</span><span class="sxs-lookup"><span data-stu-id="e3af6-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="e3af6-155">È ad esempio possibile chiamare la scomposizione Trotter-Suzuki usando le funzioni Canon seguenti, con parametri che `trotterStepSize` modificano la durata della simulazione in ogni esponenziale e `trotterOrder` per l'ordine dell'integratore desiderato.</span><span class="sxs-lookup"><span data-stu-id="e3af6-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="e3af6-156">Le applicazioni della libreria di simulazione sono descritte negli esempi.</span><span class="sxs-lookup"><span data-stu-id="e3af6-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="e3af6-157">Per la stima della fase nel modello Ising usando `SimulationAlgorithm` , vedere l' [ **esempio IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="e3af6-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="e3af6-158">Per la preparazione dello stato adiabatica nel modello Ising usando `TimeDependentSimulationAlgorithm` , vedere l' [ **esempio AdiabaticIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="e3af6-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="e3af6-159">Valutazione della fase di preparazione dello stato adiabatica &</span><span class="sxs-lookup"><span data-stu-id="e3af6-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="e3af6-160">Un'applicazione comune della simulazione hamiltoniana è la preparazione dello stato adiabatica.</span><span class="sxs-lookup"><span data-stu-id="e3af6-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="e3af6-161">Qui, ne viene fornito uno con due hamiltonians $H \_ {\Text{Start}} $ e $H \_ {\Text{end}} $ e uno stato quantico $ \ket{\psi (0)} $ che è uno stato di base dell'hamiltoniana iniziale $H \_ {\Text{Start}} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="e3af6-162">In genere, $H \_ {\Text{Start}} $ viene scelto in modo che $ \ket{\psi (0)} $ sia facile da preparare da uno stato di base computazionale $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="e3af6-163">L'interpolazione tra questi hamiltonians nel problema della simulazione dipendente dal tempo è sufficientemente lenta, ma è possibile che si concluda, con una probabilità elevata, in uno stato di base dell'Hamiltoniana finale $H \_ {\Text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="e3af6-164">Sebbene la preparazione di buone approssimazioni a stati di base di hamiltoniana possa procedere in questo modo chiamando sugli algoritmi di simulazione hamiltoniana dipendenti dal tempo come subroutine, è possibile adottare altri approcci concettuali diversi, ad esempio i eigensolver di Quantum varianti.</span><span class="sxs-lookup"><span data-stu-id="e3af6-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="e3af6-165">Un'altra applicazione onnipresente nella chimica quantistica è la stima dell'energia di stato di base di hamiltonians che rappresenta i passaggi intermedi della reazione chimica.</span><span class="sxs-lookup"><span data-stu-id="e3af6-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="e3af6-166">Uno schema di questo tipo può, ad esempio, basarsi sulla preparazione dello stato di adiabatica per creare lo stato di base e quindi incorporare la simulazione hamiltoniana indipendente dal tempo come subroutine nella caratterizzazione della valutazione della fase per estrarre questa energia con un errore finito e la probabilità di successo.</span><span class="sxs-lookup"><span data-stu-id="e3af6-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="e3af6-167">L'astrazione degli algoritmi di simulazione come tipi definiti dall'utente `SimulationAlgorithm` e `TimeDependentSimulationAlgorithm` consente di incorporare facilmente le funzionalità in algoritmi quantistici più sofisticati.</span><span class="sxs-lookup"><span data-stu-id="e3af6-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="e3af6-168">In questo modo viene motivato a eseguire la stessa operazione per le subroutine di uso comune.</span><span class="sxs-lookup"><span data-stu-id="e3af6-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="e3af6-169">Si definisce quindi la funzione comoda</span><span class="sxs-lookup"><span data-stu-id="e3af6-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="e3af6-170">Viene restituita un'operazione unitaria che implementa tutti i passaggi della preparazione dello stato di adiabatica.</span><span class="sxs-lookup"><span data-stu-id="e3af6-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="e3af6-171">Il primo parametro `interpolatedTime` definisce il tempo di interpolazione lineare tra l'Hamiltoniana iniziale descritta dal secondo parametro `evolutionGeneratorStart` e l'Hamiltoniana finale descritto dal terzo parametro `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="e3af6-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="e3af6-172">Il quarto parametro `timeDependentSimulationAlgorithm` è quello che consente di scegliere l'algoritmo di simulazione.</span><span class="sxs-lookup"><span data-stu-id="e3af6-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="e3af6-173">Si noti che se `interpolatedTime` è sufficientemente lungo, uno stato iniziale di base rimane uno stato di base istantaneo dell'Hamiltoniana per l'intera durata della simulazione dipendente dal tempo e termina quindi nello stato di base dell'Hamiltoniana finale.</span><span class="sxs-lookup"><span data-stu-id="e3af6-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="e3af6-174">Viene anche definita un'operazione utile che esegue automaticamente tutti i passaggi di un tipico esperimento di chimica quantistica.</span><span class="sxs-lookup"><span data-stu-id="e3af6-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="e3af6-175">Ad esempio, sono disponibili gli elementi seguenti, che restituisce una stima di energia dello stato prodotto dalla preparazione dello stato adiabatica:</span><span class="sxs-lookup"><span data-stu-id="e3af6-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="e3af6-176">`nQubits` numero di qubits utilizzato per codificare lo stato del quantum iniziale.</span><span class="sxs-lookup"><span data-stu-id="e3af6-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="e3af6-177">`statePrepUnitary` prepara lo stato di avvio dalla base computazionale $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="e3af6-178">`adiabaticUnitary` operazione unitaria che implementa la preparazione dello stato adiabatica, ad esempio prodotta dalla  `InterpolatedEvolution` funzione.</span><span class="sxs-lookup"><span data-stu-id="e3af6-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="e3af6-179">`qpeUnitary` operazione unitaria utilizzata per eseguire la stima della fase sullo stato del quantum risultante.</span><span class="sxs-lookup"><span data-stu-id="e3af6-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="e3af6-180">`phaseEstAlgorithm` è la scelta dell'algoritmo di stima della fase.</span><span class="sxs-lookup"><span data-stu-id="e3af6-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="e3af6-181">Le applicazioni di preparazione dello stato di adiabatica sono descritte negli esempi.</span><span class="sxs-lookup"><span data-stu-id="e3af6-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="e3af6-182">Per il modello Ising usando un'implementazione manuale della preparazione dello stato adiabatica rispetto all'uso della `AdiabaticEvolution` funzione, vedere l' [esempio **AdiabaticIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="e3af6-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="e3af6-183">Per la stima della fase e la preparazione dello stato adiabatica nel modello Ising, vedere l' [esempio **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="e3af6-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="e3af6-184">La [simulazione dell'idrogeno molecolare](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) è un esempio interessante e breve.</span><span class="sxs-lookup"><span data-stu-id="e3af6-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="e3af6-185">Il modello e i risultati sperimentali segnalati in [Malley et. al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="e3af6-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="e3af6-186">richiede solo matrici Pauli e assume il formato $ \hat H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z \_ 0} {z \_ 1} + g \_ 4 {y \_ 0} {y \_ 1} + g \_ 5 {x \_ 0} {x \_ 1} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="e3af6-187">Si tratta di un'hamiltoniana efficace che richiede solo 2 qubits, in cui le costanti $g $ vengono calcolate dalla distanza $R $ tra i due atomi idrogeno.</span><span class="sxs-lookup"><span data-stu-id="e3af6-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="e3af6-188">Con le funzioni Canon, i Paulis vengono convertiti in unitaries e quindi sviluppati in brevi periodi di tempo usando la scomposizione Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="e3af6-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="e3af6-189">È possibile creare una corretta approssimazione allo stato $H _2 $ Ground senza usare la preparazione dello stato adiabatica, quindi l'energia dello stato di base può essere trovata direttamente usando la stima della fase della Canon.</span><span class="sxs-lookup"><span data-stu-id="e3af6-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="e3af6-190">Algoritmo di Shor</span><span class="sxs-lookup"><span data-stu-id="e3af6-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="e3af6-191">L'algoritmo di Shor rimane uno degli sviluppi più significativi in quantum computing, perché ha dimostrato che i computer Quantum potevano essere usati per risolvere problemi importanti e attualmente più classici.</span><span class="sxs-lookup"><span data-stu-id="e3af6-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="e3af6-192">L'algoritmo di Shor offre un modo rapido per fattorizzare numeri elevati usando un computer quantistico, un problema denominato *factoring* .</span><span class="sxs-lookup"><span data-stu-id="e3af6-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring* .</span></span>
<span data-ttu-id="e3af6-193">La sicurezza di molti crittosistemi presenti si basa sul presupposto che non esista alcun algoritmo rapido per il factoring.</span><span class="sxs-lookup"><span data-stu-id="e3af6-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="e3af6-194">Di conseguenza, l'algoritmo di Shor ha avuto un impatto profondo sul modo in cui si pensa alla sicurezza in un mondo di post-Quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="e3af6-195">L'algoritmo di Shor può essere considerato come un algoritmo ibrido.</span><span class="sxs-lookup"><span data-stu-id="e3af6-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="e3af6-196">Il computer quantum viene usato per eseguire un'attività complessa a livello di calcolo, nota come periodo di ricerca.</span><span class="sxs-lookup"><span data-stu-id="e3af6-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="e3af6-197">I risultati dell'individuazione del periodo vengono quindi elaborati in modalità classica per stimare i fattori.</span><span class="sxs-lookup"><span data-stu-id="e3af6-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="e3af6-198">Questi due passaggi vengono esaminati di seguito.</span><span class="sxs-lookup"><span data-stu-id="e3af6-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="e3af6-199">Ricerca periodica</span><span class="sxs-lookup"><span data-stu-id="e3af6-199">Period Finding</span></span> ###

<span data-ttu-id="e3af6-200">Avendo visto il funzionamento della trasformazione e della stima della fase del quantum (vedere [algoritmi quantistici](xref:microsoft.quantum.libraries.standard.algorithms)), è possibile usare questi strumenti per risolvere un problema di calcolo di livello classico, denominato *ricerca periodica* .</span><span class="sxs-lookup"><span data-stu-id="e3af6-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding* .</span></span>  <span data-ttu-id="e3af6-201">Nella sezione successiva si vedrà come applicare il periodo di ricerca al factoring.</span><span class="sxs-lookup"><span data-stu-id="e3af6-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="e3af6-202">Dato due numeri interi $a $ e $N $, in cui $a<N $, l'obiettivo della ricerca del periodo, detto anche ricerca dell'ordine, consiste nell'individuare l' _ordine_ $r $ di $a $ modulo $N $, dove $r $ è definito come valore intero meno positivo in modo che $a ^ r \equiv 1 \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="e3af6-203">Per trovare l'ordine usando un computer Quantum, è possibile usare l'algoritmo di stima della fase applicato all'operatore unitario seguente $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \Text{mod} N}. $ $ i autovettori di $U _a $ sono per Integer $s $ e $0 \ Leq s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ sono _autostati_ di $U _A $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="e3af6-204">Gli autovalori di $U _a $ sono $ $ U \_ a \ket{x \_ s} = e ^ {2 \ PI i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="e3af6-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="e3af6-205">La valutazione della fase genera quindi gli autovalori $e ^ {2 \ PI i s/r} $ da cui $r $ possono essere apprese in modo efficiente usando [frazioni continue](https://en.wikipedia.org/wiki/Continued_fraction) da $s/r $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="e3af6-206">Il diagramma di circuito per l'individuazione del periodo Quantum è:</span><span class="sxs-lookup"><span data-stu-id="e3af6-206">The circuit diagram for quantum period finding is:</span></span>

![Diagramma di circuito per la ricerca del periodo quantico](~/media/QPE.svg)

<span data-ttu-id="e3af6-208">Qui $2n $ qubits vengono inizializzati in $ \ket {0} $ e $n $ qubits vengono inizializzati su $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="e3af6-209">Il lettore può anche chiedersi perché il registro Quantum per conservare il autostati sia inizializzato su $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="e3af6-210">Poiché non si conosce l'ordine $r $ in anticipo, non è possibile preparare gli Stati di $ \ket{x_s} $ direttamente.</span><span class="sxs-lookup"><span data-stu-id="e3af6-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="e3af6-211">Per fortuna, si scopre che $1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="e3af6-212">Non è necessario preparare effettivamente $ \ket{x} $!</span><span class="sxs-lookup"><span data-stu-id="e3af6-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="e3af6-213">È possibile preparare semplicemente un registro Quantum di $n $ qubits nello stato $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="e3af6-214">Il circuito contiene il QFT e varie attività di controllo.</span><span class="sxs-lookup"><span data-stu-id="e3af6-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="e3af6-215">Il QFT Gate è stato descritto [in precedenza](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="e3af6-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="e3af6-216">La $U controllata _a $ Gate esegue il mapping di $ \ket{x} $ a $ \ket{(AX) \Text{mod} N} $ se il controllo qubit è $ \ket {1} $ ed esegue il mapping di $ \ket{x} $ a $ \ket{x} $ in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="e3af6-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="e3af6-217">Per ottenere $ (a ^ NX) \Text{mod} N $, è possibile applicare semplicemente la $U controllata _ {a ^ N} $, dove si calcola $a ^ n \Text{mod} N $ classiche per inserire il circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="e3af6-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="e3af6-218">I circuiti per ottenere tale aritmetica modulare sono stati descritti nella [documentazione aritmetica quantistica](./algorithms.md#arithmetic), in particolare è necessario un circuito a elevate a potenza modulare per implementare le operazioni controllate-$U \_ {a ^ i} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="e3af6-219">Sebbene il circuito precedente corrisponda alla [stima della fase quantistica](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) e Abilita in modo esplicito l'individuazione degli ordini, è possibile ridurre il numero di qubits necessari.</span><span class="sxs-lookup"><span data-stu-id="e3af6-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="e3af6-220">È possibile seguire il metodo di Beauregard per l'individuazione degli ordini come descritto [nella pagina 8 di arXiv: quanti-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)oppure usare una delle routine di stima della fase disponibili in Microsoft. Quantum. characteration.</span><span class="sxs-lookup"><span data-stu-id="e3af6-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="e3af6-221">Ad esempio, la [stima della fase affidabile](xref:microsoft.quantum.characterization.robustphaseestimation) usa anche un qubit aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="e3af6-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="e3af6-222">Factoring</span><span class="sxs-lookup"><span data-stu-id="e3af6-222">Factoring</span></span> ###
<span data-ttu-id="e3af6-223">L'obiettivo del factoring consiste nel determinare i due fattori principali di Integer $N $, dove $N $ è un numero $n $ bit.</span><span class="sxs-lookup"><span data-stu-id="e3af6-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="e3af6-224">Il factoring è costituito dai passaggi descritti di seguito.</span><span class="sxs-lookup"><span data-stu-id="e3af6-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="e3af6-225">I passaggi sono suddivisi in tre parti: una routine di pre-elaborazione classica (1-4); routine di calcolo quantistica per trovare l'ordine di $a mod \Text{} N $ (5); e una routine di postelaborazione classica per derivare i fattori principali dall'ordine (6-9).</span><span class="sxs-lookup"><span data-stu-id="e3af6-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="e3af6-226">La routine di pre-elaborazione classica prevede i passaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="e3af6-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="e3af6-227">Se $N $ è pari, restituire il fattore principale $2 $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="e3af6-228">Se $N = p ^ q $ per $p \geq1 $, $q \geq2 $, restituire il fattore principale $p $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="e3af6-229">Questo passaggio viene eseguito in modalità classica.</span><span class="sxs-lookup"><span data-stu-id="e3af6-229">This step is performed classically.</span></span>
3. <span data-ttu-id="e3af6-230">Scegliere un numero casuale $a $ tale che $1 < un < N-$1.</span><span class="sxs-lookup"><span data-stu-id="e3af6-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="e3af6-231">Se $ \Text{GCD} (a, N) >$1, restituisce il fattore principale $ \Text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="e3af6-232">Questo passaggio viene calcolato usando l'algoritmo di Euclide.</span><span class="sxs-lookup"><span data-stu-id="e3af6-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="e3af6-233">Se non viene restituito alcun fattore principale, si procede alla routine Quantum:</span><span class="sxs-lookup"><span data-stu-id="e3af6-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="e3af6-234">Chiamare l'algoritmo di ricerca del periodo quantico per calcolare l'ordine $r $ of $a \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="e3af6-235">Usare $r $ nella routine di postelaborazione classica per determinare i fattori principali:</span><span class="sxs-lookup"><span data-stu-id="e3af6-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="e3af6-236">Se $r $ è dispari, tornare al passaggio di pre-elaborazione (3).</span><span class="sxs-lookup"><span data-stu-id="e3af6-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="e3af6-237">Se $r $ è pari e $a ^ {r/2} =-1 \ text {mod} N $, tornare al passaggio di pre-elaborazione (3).</span><span class="sxs-lookup"><span data-stu-id="e3af6-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="e3af6-238">Se $ \Text{GCD} (a ^ {r/2} + 1, N) $ è un fattore non semplice di $N $, restituisce $ \Text{GCD} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="e3af6-239">Se $ \Text{GCD} (a ^ {r/2}-1, N) $ è un fattore non semplice di $N $, restituisce $ \Text{GCD} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="e3af6-240">L'algoritmo di factoring è probabilistico: è possibile che con la probabilità sia presente almeno una metà che $r $ sarà pari e $a ^ {r/2} \neq-1 \Text{mod} N $, producendo così un fattore di primo livello.</span><span class="sxs-lookup"><span data-stu-id="e3af6-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="e3af6-241">Per [informazioni](xref:microsoft.quantum.more-information)dettagliate, vedere il [documento originale di Shor](https://doi.org/10.1109/SFCS.1994.365700) o uno dei testi di *calcolo Quantum di base* in.</span><span class="sxs-lookup"><span data-stu-id="e3af6-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="e3af6-242">Se non viene restituito un fattore principale, si ripete semplicemente l'algoritmo dal passaggio (1).</span><span class="sxs-lookup"><span data-stu-id="e3af6-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="e3af6-243">Dopo $n $ tentativi, la probabilità che ogni tentativo abbia esito negativo è maggiore di $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="e3af6-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="e3af6-244">Quindi, dopo aver ripetuto l'algoritmo, un numero ridotto di volte l'esito positivo è praticamente sicuro.</span><span class="sxs-lookup"><span data-stu-id="e3af6-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
