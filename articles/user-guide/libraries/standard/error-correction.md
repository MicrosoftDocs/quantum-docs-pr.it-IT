---
title: 'Correzione degli errori nelle :::no-loc(Q#)::: librerie standard'
description: 'Informazioni su come usare i codici di correzione degli errori nei :::no-loc(Q#)::: programmi, proteggendo allo stesso tempo lo stato del qubits.'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 94251e185cea65c5fc08ed70d5fba9b7b19501e3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692045"
---
# <a name="error-correction"></a><span data-ttu-id="b5a44-103">Correzione errori</span><span class="sxs-lookup"><span data-stu-id="b5a44-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="b5a44-104">Introduzione</span><span class="sxs-lookup"><span data-stu-id="b5a44-104">Introduction</span></span> ##

<span data-ttu-id="b5a44-105">Nell'elaborazione classica, se si vuole proteggere un bit da errori, spesso è sufficiente rappresentare tale bit per un *bit logico* ripetendo il bit di dati.</span><span class="sxs-lookup"><span data-stu-id="b5a44-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="b5a44-106">Ad esempio, Let $ \overline {0} = $0 è la codifica del bit di dati 0, in cui viene usata la riga a sopra l'etichetta 0 per indicare che si tratta di una codifica di un bit nello stato 0.</span><span class="sxs-lookup"><span data-stu-id="b5a44-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="b5a44-107">Se si lascia in modo analogo $ \overline {1} = $111, è disponibile un semplice codice di ripetizione che protegge da qualsiasi errore di capovolgimento di un bit.</span><span class="sxs-lookup"><span data-stu-id="b5a44-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="b5a44-108">Ovvero, se uno dei tre bit viene capovolto, è possibile recuperare lo stato del bit logico prendendo un voto di maggioranza.</span><span class="sxs-lookup"><span data-stu-id="b5a44-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="b5a44-109">Sebbene la correzione degli errori classica sia un argomento molto più completo che questo particolare esempio (si consiglia di [introdurre la teoria di codifica](https://www.springer.com/us/book/9783540641339)), il codice di ripetizione precedente punta già a un possibile problema nella protezione delle informazioni sui quantum.</span><span class="sxs-lookup"><span data-stu-id="b5a44-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="b5a44-110">In particolare, il [teorema di no-cloning](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implica che se misuriamo ogni singolo qubit e scegliamo una maggioranza di voti per analogia con il codice classico precedente, abbiamo perso le informazioni precise che stiamo tentando di proteggere.</span><span class="sxs-lookup"><span data-stu-id="b5a44-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="b5a44-111">Nell'impostazione Quantum si noterà che la misurazione è problematica.</span><span class="sxs-lookup"><span data-stu-id="b5a44-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="b5a44-112">È comunque possibile implementare la codifica precedente.</span><span class="sxs-lookup"><span data-stu-id="b5a44-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="b5a44-113">È utile eseguire questa operazione per vedere come è possibile generalizzare la correzione degli errori nel caso del quantum.</span><span class="sxs-lookup"><span data-stu-id="b5a44-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="b5a44-114">Quindi, Let $ \ket{\overline {0} } = \ket {000} = \ket {0} \otimes \ket {0} \otimes \ket {0} $ e Let $ \ket{\overline {1} } = \ket {111} $.</span><span class="sxs-lookup"><span data-stu-id="b5a44-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="b5a44-115">Quindi, per linearità, abbiamo definito il nostro codice di ripetizione per tutti gli input; ad esempio, $ \ket{\overline{+}} = (\ket{\overline {0} } + \ket{\overline {1} })/\sqrt {2} = (\ket {000} + \ket {111} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="b5a44-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="b5a44-116">In particolare, se si lascia un errore di capovolgimento $X _1 $ Act sulla qubit centrale, si noterà che la correzione necessaria in entrambi i rami è precisa $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac {1} {\sqrt {2} } \left (X_1 \ket {000} + X_1 \ket {111} \right) \\ \\ & = \frac {1} {\sqrt {2} } \left (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="b5a44-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="b5a44-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="b5a44-117">\end{align} $$</span></span>

<span data-ttu-id="b5a44-118">Per capire in che modo è possibile identificare questo problema senza misurare lo stato che si sta tentando di proteggere, è utile prendere nota della situazione di ogni singolo errore di Flip bit per gli stati logici:</span><span class="sxs-lookup"><span data-stu-id="b5a44-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="b5a44-119">Errore $E $</span><span class="sxs-lookup"><span data-stu-id="b5a44-119">Error $E$</span></span> | <span data-ttu-id="b5a44-120">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="b5a44-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="b5a44-121">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="b5a44-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="b5a44-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="b5a44-122">$\boldone$</span></span> | <span data-ttu-id="b5a44-123">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-123">$\ket{000}$</span></span> | <span data-ttu-id="b5a44-124">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-124">$\ket{111}$</span></span> |
| <span data-ttu-id="b5a44-125">$X_0$</span><span class="sxs-lookup"><span data-stu-id="b5a44-125">$X_0$</span></span> | <span data-ttu-id="b5a44-126">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-126">$\ket{100}$</span></span> | <span data-ttu-id="b5a44-127">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-127">$\ket{011}$</span></span> |
| <span data-ttu-id="b5a44-128">$X_1$</span><span class="sxs-lookup"><span data-stu-id="b5a44-128">$X_1$</span></span> | <span data-ttu-id="b5a44-129">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-129">$\ket{010}$</span></span> | <span data-ttu-id="b5a44-130">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-130">$\ket{101}$</span></span> |
| <span data-ttu-id="b5a44-131">$X_2$</span><span class="sxs-lookup"><span data-stu-id="b5a44-131">$X_2$</span></span> | <span data-ttu-id="b5a44-132">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-132">$\ket{001}$</span></span> | <span data-ttu-id="b5a44-133">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-133">$\ket{110}$</span></span> |

<span data-ttu-id="b5a44-134">Per proteggere lo stato che si sta codificando, è necessario essere in grado di distinguere i tre errori l'uno dall'altro e dall'identità $ \boldone $ senza distinguere tra $ \ket{\overline {0} } $ e $ \ket{\overline {1} } $.</span><span class="sxs-lookup"><span data-stu-id="b5a44-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="b5a44-135">Se, ad esempio, si misura $Z _0 $, si ottiene un risultato diverso per $ \ket{\overline {0} } $ e $ \ket{\overline {1} } $ nel caso senza errori, in modo da comprimere lo stato codificato.</span><span class="sxs-lookup"><span data-stu-id="b5a44-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="b5a44-136">D'altra parte, prendere in considerazione la misurazione $Z _0 Z_1 $, la parità dei primi due bit in ogni stato di base di calcolo.</span><span class="sxs-lookup"><span data-stu-id="b5a44-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="b5a44-137">Tenere presente che ogni misura di un operatore di Pauli controlla quale autovalore lo stato misurato corrisponde a, quindi, per ogni stato $ \ket{\psi} $ nella tabella precedente, è possibile calcolare $Z _0 Z_1 \ket{\psi} $ per verificare se si ottiene $ \pm\ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="b5a44-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="b5a44-138">Si noti che $Z _0 Z_1 \ket {000} = \ket {000} $ e che $Z _0 Z_1 \ket {111} = \ket {111} $, in modo da concludere che questa misurazione esegue la stessa operazione in entrambi gli stati codificati.</span><span class="sxs-lookup"><span data-stu-id="b5a44-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="b5a44-139">D'altra parte, $Z _0 Z_1 \ket {100} =-\ket {100} $ e $Z _0 Z_1 \ket {011} =-\ket {011} $, quindi il risultato della misurazione $Z _0 Z_1 $ rivela informazioni utili sull'errore che si è verificato.</span><span class="sxs-lookup"><span data-stu-id="b5a44-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="b5a44-140">Per evidenziare questo problema, si ripete la tabella precedente, ma si aggiungono i risultati della misurazione $Z _0 Z_1 $ e $Z _1 Z_2 $ a ogni riga.</span><span class="sxs-lookup"><span data-stu-id="b5a44-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="b5a44-141">I risultati di ogni misura vengono identificati in base al segno di autovalore osservato, ovvero $ + $ o $-$, corrispondenti :::no-loc(Q#)::: `Result` rispettivamente ai valori di `Zero` e `One` .</span><span class="sxs-lookup"><span data-stu-id="b5a44-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the :::no-loc(Q#)::: `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="b5a44-142">Errore $E $</span><span class="sxs-lookup"><span data-stu-id="b5a44-142">Error $E$</span></span> | <span data-ttu-id="b5a44-143">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="b5a44-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="b5a44-144">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="b5a44-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="b5a44-145">Risultato della $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="b5a44-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="b5a44-146">Risultato della $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="b5a44-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="b5a44-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="b5a44-147">$\boldone$</span></span> | <span data-ttu-id="b5a44-148">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-148">$\ket{000}$</span></span> | <span data-ttu-id="b5a44-149">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="b5a44-150">$X_0$</span><span class="sxs-lookup"><span data-stu-id="b5a44-150">$X_0$</span></span> | <span data-ttu-id="b5a44-151">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-151">$\ket{100}$</span></span> | <span data-ttu-id="b5a44-152">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="b5a44-153">$X_1$</span><span class="sxs-lookup"><span data-stu-id="b5a44-153">$X_1$</span></span> | <span data-ttu-id="b5a44-154">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-154">$\ket{010}$</span></span> | <span data-ttu-id="b5a44-155">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="b5a44-156">$X_2$</span><span class="sxs-lookup"><span data-stu-id="b5a44-156">$X_2$</span></span> | <span data-ttu-id="b5a44-157">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-157">$\ket{001}$</span></span> | <span data-ttu-id="b5a44-158">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="b5a44-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="b5a44-159">In questo modo, i risultati delle due misure determinano in modo univoco quale errore di Flip bit si è verificato, ma senza rivelare informazioni sullo stato codificato.</span><span class="sxs-lookup"><span data-stu-id="b5a44-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="b5a44-160">Questi risultati vengono chiamati una *sindrome* e si fa riferimento al processo di mapping di una sindrome all'errore che lo ha causato come *ripristino* .</span><span class="sxs-lookup"><span data-stu-id="b5a44-160">We call these results a *syndrome* , and refer to the process of mapping a syndrome back to the error that caused it as *recovery* .</span></span>
<span data-ttu-id="b5a44-161">In particolare, viene evidenziato che il ripristino è una procedura di inferenza *classica* che accetta come input la sindrome che si è verificata e restituisce una prescrizione per la risoluzione degli errori che potrebbero essersi verificati.</span><span class="sxs-lookup"><span data-stu-id="b5a44-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="b5a44-162">Il codice di capovolgimento dei bit precedente può essere corretto solo in caso di errori di singolo capovolgimento. ovvero un'operazione che `X` agisce su un singolo qubit.</span><span class="sxs-lookup"><span data-stu-id="b5a44-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="b5a44-163">Se `X` si applica a più di un qubit, il mapping di $ \ket{\overline {0} } $ a $ \ket{\overline {1} } $ segue il ripristino.</span><span class="sxs-lookup"><span data-stu-id="b5a44-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="b5a44-164">Analogamente, l'applicazione di un'operazione Phase Flip `Z` eseguirà il mapping di $ \ket{\overline {1} } $ a $-\ket{\overline {1} } $, quindi eseguirà il mapping di $ \ket{\overline{+}} $ a $ \ket{\overline {-} } $.</span><span class="sxs-lookup"><span data-stu-id="b5a44-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="b5a44-165">Più in generale, è possibile creare codici per gestire un numero maggiore di errori e gestire $Z $ Errors, nonché $X $ Errors.</span><span class="sxs-lookup"><span data-stu-id="b5a44-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="b5a44-166">Il modo in cui è possibile descrivere le misurazioni nella correzione degli errori quantistici che operano allo stesso modo su tutti gli Stati del codice è l'essenza del *formalismo di stabilizzazione* .</span><span class="sxs-lookup"><span data-stu-id="b5a44-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism* .</span></span>
<span data-ttu-id="b5a44-167">La :::no-loc(Q#)::: canonica fornisce un Framework per descrivere la codifica e la decodifica da codici di stabilizzatori e per descrivere la modalità di ripristino da errori.</span><span class="sxs-lookup"><span data-stu-id="b5a44-167">The :::no-loc(Q#)::: canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="b5a44-168">In questa sezione viene descritto questo Framework e la relativa applicazione per alcuni semplici codici di correzione degli errori quantistici.</span><span class="sxs-lookup"><span data-stu-id="b5a44-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="b5a44-169">Un'introduzione completa al formalismo di stabilizzatore esula dall'ambito di questa sezione.</span><span class="sxs-lookup"><span data-stu-id="b5a44-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="b5a44-170">Ci riferiamo ai lettori interessati a saperne di più su [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="b5a44-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="b5a44-171">Rappresentazione di codici di correzione degli errori in :::no-loc(Q#):::</span><span class="sxs-lookup"><span data-stu-id="b5a44-171">Representing Error Correcting Codes in :::no-loc(Q#):::</span></span> ##

<span data-ttu-id="b5a44-172">Per consentire di specificare i codici di correzione degli errori, la :::no-loc(Q#)::: Canon fornisce diversi tipi distinti definiti dall'utente:</span><span class="sxs-lookup"><span data-stu-id="b5a44-172">To help specify error correcting codes, the :::no-loc(Q#)::: canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="b5a44-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Indica che un registro di qubits deve essere interpretato come il blocco di codice di un codice di correzione degli errori.</span><span class="sxs-lookup"><span data-stu-id="b5a44-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="b5a44-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Indica che una matrice di risultati di misurazione deve essere interpretata come la sindrome misurata in un blocco di codice.</span><span class="sxs-lookup"><span data-stu-id="b5a44-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="b5a44-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Indica che è necessario usare una funzione *classica* per interpretare una sindrome e restituire una correzione da applicare.</span><span class="sxs-lookup"><span data-stu-id="b5a44-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="b5a44-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Indica che un'operazione accetta qubits che rappresentano i dati insieme a qubits ancilla aggiornati per produrre un blocco di codice di un codice di correzione degli errori.</span><span class="sxs-lookup"><span data-stu-id="b5a44-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="b5a44-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Indica che un'operazione scompone un blocco di codice di un errore durante la correzione del codice nei dati qubits e Ancilla qubits utilizzati per rappresentare le informazioni sulla sindrome.</span><span class="sxs-lookup"><span data-stu-id="b5a44-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="b5a44-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Indica un'operazione da usare per estrarre le informazioni sulla sindrome da un blocco di codice, senza compromettere lo stato protetto dal codice.</span><span class="sxs-lookup"><span data-stu-id="b5a44-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="b5a44-179">Infine, la canonica fornisce il <xref:Microsoft.Quantum.ErrorCorrection.QECC> tipo per raccogliere gli altri tipi necessari per definire un codice di correzione degli errori Quantum.</span><span class="sxs-lookup"><span data-stu-id="b5a44-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="b5a44-180">Associato a ogni codice Quantum di stabilizzatore è la lunghezza del codice $n $, il numero $k $ dei qubits logici e la distanza minima $d $, spesso raggruppati insieme nella notazione ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="b5a44-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="b5a44-181">Ad esempio, la <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> funzione definisce il ⟦ 3, 1, 1 ⟧ bit flip code:</span><span class="sxs-lookup"><span data-stu-id="b5a44-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="b5a44-182">Si noti che il `QECC` tipo *non* include una funzione di ripristino.</span><span class="sxs-lookup"><span data-stu-id="b5a44-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="b5a44-183">Questo consente di modificare la funzione di ripristino usata per correggere gli errori senza modificare la definizione del codice stesso. Questa possibilità è particolarmente utile quando si incorporano commenti e suggerimenti dalle misurazioni di caratterizzazione nel modello presupposto dal ripristino.</span><span class="sxs-lookup"><span data-stu-id="b5a44-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="b5a44-184">Una volta definito un codice in questo modo, è possibile usare l' <xref:Microsoft.Quantum.ErrorCorrection.Recover> operazione per correggere gli errori:</span><span class="sxs-lookup"><span data-stu-id="b5a44-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="b5a44-185">Questo aspetto viene esaminato più dettagliatamente nell' [esempio di codice di Flip bit](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="b5a44-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="b5a44-186">Oltre al codice di Flip bit, il :::no-loc(Q#)::: canone viene fornito con le implementazioni del codice [perfetto qubit](https://arxiv.org/abs/quant-ph/9602019)e il [codice qubit](https://arxiv.org/abs/quant-ph/9705052), che possono correggere un errore arbitrario qubit singolo.</span><span class="sxs-lookup"><span data-stu-id="b5a44-186">Aside from the bit-flip code, the :::no-loc(Q#)::: canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
