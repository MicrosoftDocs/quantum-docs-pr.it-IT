---
title: 'Algoritmi Quantum in Q #'
description: Informazioni sugli algoritmi di calcolo Quantum di base, tra cui l'amplificazione dell'ampiezza, la trasformazione di Fourier, i Adder e la stima della fase.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 7f4916353c53d6459356243098281ccb16b17278
ms.sourcegitcommit: cdf67362d7b157254e6fe5c63a1c5551183fc589
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/21/2020
ms.locfileid: "86871315"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="1f0e1-103">Algoritmi Quantum</span><span class="sxs-lookup"><span data-stu-id="1f0e1-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="1f0e1-104">Amplificazione dell'altitudine</span><span class="sxs-lookup"><span data-stu-id="1f0e1-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="1f0e1-105">L' *amplificazione dell'ampiezza* è uno degli strumenti fondamentali del quantum computing.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="1f0e1-106">Si tratta dell'idea fondamentale che sottende la ricerca di Grover, la stima dell'ampiezza e molti algoritmi di Machine Learning Quantum.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="1f0e1-107">Sono disponibili molte varianti e in Q # viene fornita una versione generale basata sull'amplificazione dell'ampiezza ignara con riflessi parziali per consentire l'area dell'applicazione più ampia.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="1f0e1-108">L'idea centrale dietro l'amplificazione dell'ampiezza consiste nell'ampliare la probabilità di un risultato desiderato, eseguendo una sequenza di riflessi.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="1f0e1-109">Queste riflessioni ruotano lo stato iniziale verso uno stato di destinazione desiderato, spesso definito stato contrassegnato.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="1f0e1-110">In particolare, se la probabilità di misurare lo stato iniziale in uno stato contrassegnato è $ \sin ^ 2 (\theta) $, dopo aver applicato l'amplificazione dell'ampiezza $m $ volte la probabilità di successo diventa $ \sin ^ 2 ((2m + 1) \theta) $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="1f0e1-111">Ciò significa che se $ \theta = \ PI/[2 (2n + 1)] $ per un valore pari a $n $ then, l'amplificazione dell'ampiezza è in grado di aumentare la probabilità di successo fino al $100 \\ % $ dopo $n le iterazioni $ dell'amplificazione dell'ampiezza.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="1f0e1-112">Dal momento che $ \theta = \sin ^ {-1} (\sqrt{\Pr (Success)}) $ questo significa che il numero di iterazioni necessarie per ottenere una riuscita in modo deterministico è quadratico inferiore al numero previsto necessario per trovare uno stato contrassegnato in modo non deterministico usando il campionamento casuale.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="1f0e1-113">Ogni iterazione dell'amplificazione dell'ampiezza richiede la specifica di due operatori di Reflection.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="1f0e1-114">In particolare, se $Q $ è l'amplificazione dell'ampiezza iterata e $P _0 $ è un operatore proiettore sul sottospazio iniziale e $P _1 $ è il proiettore sul sottospazio contrassegnato, $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="1f0e1-115">Tenere presente che un proiettore è un operatore Hermitiane con autovalori $ + $1 e $0 $ e, di conseguenza, $ (\boldone-2P_0) $ è unitario perché contiene autonomi che sono radici di Unity (in questo caso $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="1f0e1-116">Si consideri ad esempio il caso della ricerca di Grover con lo stato iniziale $H ^ {\otimes n} \ket {0} $ e lo stato contrassegnato $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket {0} \bra {0} H ^ {\otimes n} $ e $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="1f0e1-117">Nella maggior parte delle applicazioni di amplificazione dell'ampiezza $P _0 $ sarà un proiettore con uno stato iniziale che significa che $P _0 = \boldone-2 \ KET {\ psi} \ Bra {\ psi} $ per some Vector $ \ket{\psi} $; Tuttavia, per l'ampiezza ignara amplication $P _0 $ generalmente proiettano su molti stati Quantum, ovvero la molteplicità dei autovalore $ + $1 di $P _0 $ è maggiore di $1 $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="1f0e1-118">La logica alla base dell'amplificazione dell'ampiezza segue direttamente dalla decomposizione autovettori di $Q $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="1f0e1-119">In particolare, il autovettori di $Q $ che lo stato iniziale ha un supporto diverso da zero può essere indicato come combinazioni lineari del autovettori $ + $1 di $P _0 $ e $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="1f0e1-120">In particolare, lo stato iniziale per l'amplificazione dell'ampiezza (presupponendo che si tratta di un autovettore $ + $1 di $P _0 $) può essere scritto come $ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \left (e ^ {i\theta} \ KET {\ psi_ +} + e ^ {-i\theta} \ KET {\ psi_-} \right), $ $ where $ \ket{\ psi_ \pm} $ sono autovettori di $Q $ con autovalori $e ^ {\pm 2i \ theta} $ e dispongono solo del supporto per la autovettori $ + $1 di $P _0 $ e $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="1f0e1-121">Il fatto che gli autovalori siano $e ^ {\pm i \theta} $ implica che l'operatore $Q $ esegue una rotazione in un sottospazio bidimensionale specificato dai due proiettori e lo stato iniziale in cui l'angolo di rotazione è $2 \ Theta $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="1f0e1-122">Questo è il motivo per cui dopo la $m $ iterazioni di $Q $ la probabilità di successo è $ \sin ^ 2 ([2m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="1f0e1-123">Un'altra proprietà utile che deriva da questo è che autovalore $ \theta $ è direttamente correlato alla probabilità che lo stato iniziale venga contrassegnato (nel caso in cui $P _0 $ sia un proiettore solo nello stato iniziale).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="1f0e1-124">Poiché il valore di eigenphases di $Q $ è $2 \ Theta = 2 \ sin ^ {-1} (\sqrt{\Pr (Success)}), $ it segue che, se applichiamo la stima della fase a $Q $, possiamo apprendere la probabilità di successo per una procedura quantistica unitaria.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="1f0e1-125">Questa operazione è utile perché richiede un minor numero di applicazioni della procedura quantistica per apprendere la probabilità di successo che altrimenti sarebbe necessario.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="1f0e1-126">Q # introduce l'amplificazione dell'ampiezza come specializzazione dell'amplificazione dell'ampiezza ignara.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="1f0e1-127">L'amplificazione dell'ampiezza ignara ottiene questo moniker perché il proiettore sul eigenspace iniziale non deve essere un proiettore sullo stato iniziale.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="1f0e1-128">In questo senso, il protocollo è ignaro dello stato iniziale.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="1f0e1-129">L'applicazione principale dell'amplificazione dell'ampiezza ignara è *costituita da alcune combinazioni lineari di metodi di simulazione hamiltoniana unitaria* , in cui lo stato iniziale è sconosciuto, ma diventa un registro ancilla nel protocollo di simulazione.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="1f0e1-130">Se il registro ancilla deve essere misurato come valore fisso, ad esempio $0 $, questi metodi di simulazione applicano la trasformazione unitaria desiderata al qubits rimanente (denominato Registro di sistema).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="1f0e1-131">Tutti gli altri risultati di misurazione portano tuttavia a un errore.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="1f0e1-132">L'amplificazione dell'ampiezza indesiderata consente di incrementare la probabilità di successo di questa misurazione al $100 \\ % $ usando i motivi precedenti.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="1f0e1-133">Inoltre, l'amplificazione dell'ampiezza ordinaria corrisponde al caso in cui il registro di sistema è vuoto.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="1f0e1-134">Questo è il motivo per cui Q # usa l'amplificazione dell'ampiezza ignara come subroutine di amplificazione dell'ampiezza.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="1f0e1-135">La routine generale ( `AmpAmpObliviousByReflectionPhases` ) ha due registri chiamati `ancillaRegister` e `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="1f0e1-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="1f0e1-136">Accetta inoltre due Oracle per le riflessioni necessarie.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="1f0e1-137">`ReflectionOracle`Agisce solo su `ancillaRegister` mentre `ObliviousOracle` agisce congiuntamente su entrambi i registri.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="1f0e1-138">L'input per `ancillaRegister` deve essere inizializzato su un autostato-1 del primo operatore di Reflection $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="1f0e1-139">In genere, Oracle prepara lo stato in base al calcolo $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="1f0e1-140">Nell'implementazione di `ancillaRegister` è costituito da un qubit ( `flagQubit` ) che controlla `stateOracle` e il resto del ancillas desiderato.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="1f0e1-141">`stateOracle`Viene applicato quando `flagQubit` è $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="1f0e1-142">Uno può anche fornire Oracle `StateOracle` e `ObliviousOracle` invece di riflessioni tramite una chiamata a `AmpAmpObliviousByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="1f0e1-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="1f0e1-143">Come indicato in precedenza, l'amplificazione dell'ampiezza tradizionale è solo un caso speciale di queste routine in cui `ObliviousOracle` è l'operatore di identità e non sono presenti qubits di sistema (ovvero, `systemRegister` è vuoto).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="1f0e1-144">Se si desidera ottenere fasi per riflessioni parziali, ad esempio per la ricerca Grover, la funzione `AmpAmpPhasesStandard` è disponibile.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="1f0e1-145">`DatabaseSearch.qs`Per un'implementazione di esempio dell'algoritmo di Grover, fare riferimento a.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="1f0e1-146">Si mettono in relazione le fasi di rotazione con singolo qubit alle fasi dell'operatore di reflection, come descritto nel documento di [G.H. Low, i. L. Chuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="1f0e1-147">Le fasi a virgola fissa utilizzate sono descritte in dettaglio in [Yoder, low e Chuang](https://arxiv.org/abs/1409.3305) insieme alle fasi in [low, Yoder e Chuang](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="1f0e1-148">Per informazioni di base, è possibile iniziare dall' [amplificazione dell'ampiezza standard](https://arxiv.org/abs/quant-ph/0005055) , quindi passare a un'introduzione all' [amplificazione dell'ampiezza ignara](https://arxiv.org/abs/1312.1414) e infine alle generalizzazioni presentate in [low e Chuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="1f0e1-149">Una panoramica di questa intera area (in relazione alla simulazione Hamiltoniana) è stata fornita da [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="1f0e1-150">Trasformazione Quantum Fourier</span><span class="sxs-lookup"><span data-stu-id="1f0e1-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="1f0e1-151">La trasformazione Fourier è uno strumento fondamentale di analisi classica ed è altrettanto importante per i calcoli quantistici.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="1f0e1-152">Inoltre, l'efficienza della *trasformazione Quantum Fourier Transform* (QFT) supera di molto ciò che è possibile in un computer classico, rendendolo uno dei primi strumenti da scegliere quando si progetta un algoritmo Quantum.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="1f0e1-153">Come generalizzazione approssimativa del QFT, viene fornita l' <xref:microsoft.quantum.canon.approximateqft> operazione che consente di ottimizzare ulteriormente le rotazioni che non sono strettamente necessarie per l'accuratezza algoritmica desiderata.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="1f0e1-154">Il QFT approssimativo richiede l'operazione di diadico $Z $-Rotation <xref:microsoft.quantum.intrinsic.rfrac> e l' <xref:microsoft.quantum.intrinsic.h> operazione.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="1f0e1-155">Si presuppone che l'input e l'output siano codificati nella codifica big endian---, ovvero qubit con index `0` è codificato nel bit più a sinistra (più alto) della rappresentazione di valori integer binari.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="1f0e1-156">Questa operazione è allineata alla [notazione KET](xref:microsoft.quantum.concepts.dirac), perché un registro di tre qubits nello stato $ \ket {100} $ corrisponde a $q _0 $ si trova nello stato $ \ket {1} $ mentre $q _1 $ e $q _2 $ sono entrambi nello stato $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="1f0e1-157">Il parametro di approssimazione $a $ determina il livello di eliminazione delle $Z $-rotations, ad esempio $a \In [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="1f0e1-158">In questo caso tutti i $Z $-rotations $2 \ PI/2 ^ k $ dove $k > $ vengono rimossi dal circuito QFT.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="1f0e1-159">Si noti che per $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="1f0e1-160">uno può associare $ \\ | \operatorname{QFT}-\operatorname{AQFT} \\ | < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="1f0e1-161">Qui $ \\ | \cdot \\ | $ è la norma dell'operatore, che in questo caso è la radice quadrata della [autovalore](xref:microsoft.quantum.concepts.matrix-advanced) più grande di $ (\operatorname{QFT}-\operatorname{AQFT}) (\operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="1f0e1-162">Aritmetico</span><span class="sxs-lookup"><span data-stu-id="1f0e1-162">Arithmetic</span></span> ##

<span data-ttu-id="1f0e1-163">Proprio come l'aritmetica svolge un ruolo centrale nell'elaborazione classica, è anche indispensabile in quantum computing.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="1f0e1-164">Gli algoritmi come l'algoritmo di factoring di Shor, i metodi di simulazione quantistica e molti algoritmi oracolare si basano su operazioni aritmetiche coerenti.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="1f0e1-165">La maggior parte degli approcci alla compilazione aritmetica sui circuiti Quantum Adder.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="1f0e1-166">Il Adder più semplice accetta un input classico $b $ e aggiunge il valore a uno stato quantum contenente un Integer $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="1f0e1-167">In matematica, il Adder (che indica $ \operatorname{Add} (b) $ per l'input classico $b $) ha la proprietà che</span><span class="sxs-lookup"><span data-stu-id="1f0e1-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="1f0e1-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="1f0e1-169">$ $ Questo circuito di base di Adder è più di un incremento rispetto a un Adder.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="1f0e1-170">Può essere convertito in un Adder con due input Quantum tramite $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}, $ $ usando $n applicazioni $ controllate di viperes nel formato \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left (\operatorname{Add} (1) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \Lambda \_ {a \_ {n-1}} \left (\operatorname{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} per $n interi a $ bit $a $ e $b $ e modulo di aggiunta $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="1f0e1-171">Tenere presente che la notazione $ \Lambda \_ x (a) $ fa riferimento, per qualsiasi operazione $A $, alla versione controllata di tale operazione con il qubit $x $ As.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="1f0e1-172">Analogamente, la moltiplicazione controllata in modo classico (un formato modulare di cui è essenziale per l'algoritmo di factoring di Shor) può essere eseguita usando una serie simile di aggiunte controllate: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda \_ {x \_ 0} \Left (\operatorname{Add} (2 ^ 0 a) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda \_ {x \_ {n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="1f0e1-173">\end{align} esiste una sottigliezza con la moltiplicazione per i computer Quantum che è possibile notare dalla definizione di $ \operatorname{Mult} $ precedente.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="1f0e1-174">A differenza dell'aggiunta, la versione Quantum di questo circuito archivia il prodotto degli input in un registro ausiliario anziché nel registro di input.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="1f0e1-175">In questo esempio, il registro viene inizializzato con il valore $b $, ma in genere inizierà a contenere il valore zero.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="1f0e1-176">Questa operazione è necessaria in perché in generale non è presente un inverso di moltiplicazione per il generale $a $ e $x $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="1f0e1-177">Poiché tutte le operazioni Quantum, Save Measurement, sono reversibili è necessario conservare informazioni sufficienti per invertire la moltiplicazione.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="1f0e1-178">Per questo motivo il risultato viene archiviato in una matrice separata.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="1f0e1-179">Questo espediente che consente di salvare l'output di un'operazione irreversibile, come la moltiplicazione, in un registro separato è noto come "Bennett Trick" dopo Charlie Bennett ed è uno strumento fondamentale per l'elaborazione reversibile e Quantum.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="1f0e1-180">Molti circuiti Quantum sono stati proposti per l'aggiunta e ognuno Esplora un compromesso diverso in termini di numero di qubits (spazio) e numero di operazioni di controllo (tempo) necessarie.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="1f0e1-181">In questo esempio vengono esaminati due vipere efficienti a livello di spazio inferiore, noti come Adder Draper e la vipera Beauregard.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="1f0e1-182">Vipera Draper</span><span class="sxs-lookup"><span data-stu-id="1f0e1-182">Draper Adder</span></span> ###

<span data-ttu-id="1f0e1-183">Il Adder Draper è probabilmente uno dei Viper di quantum più eleganti, perché richiama direttamente le proprietà Quantum per eseguire l'addizione.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="1f0e1-184">La conoscenza dietro la vipera Draper è che la trasformazione di Fourier può essere usata per tradurre i turni di fase in uno spostamento di bit.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="1f0e1-185">Segue quindi questa operazione applicando una trasformazione di Fourier, applicando turni di fase appropriati e quindi anmutando la trasformazione di Fourier è possibile implementare un Adder.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="1f0e1-186">A differenza di molti altri Viper che sono stati proposti, il Adder Draper USA in modo esplicito gli effetti quantistici introdotti tramite la trasformazione Quantum Fourier.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="1f0e1-187">Non ha una controparte classica naturale.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="1f0e1-188">Di seguito sono riportati i passaggi specifici del Adder Draper.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="1f0e1-189">Si supponga di disporre di $n due registri qubit a $ bit che archiviano i numeri interi $a $ e $b $, per tutti $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="1f0e1-190">$ $ Se si definisce $ $ \ket{\Phi \_ k (a)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi a/2 ^ k} \ket {1} \right), $ $ quindi dopo alcune algebra si noterà che $ $ \operatorname{QFT}\ket{a} = \ket{\Phi \_ 1 (a)} \otimes \cdots \otimes \ket{\Phi \_ n (a)}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="1f0e1-191">$ $ Il percorso per l'esecuzione di un Adder diventa chiaro dopo aver osservato che la somma degli input può essere scritta come $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\Phi \_ 1 (a + b)} \otimes \cdots \otimes \ket{\Phi \_ n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="1f0e1-192">$ $ I numeri interi $b $ e $a $ possono quindi essere aggiunti eseguendo la rotazione controllata in fase di ogni qubits nella scomposizione usando i bit di $b $ come controlli.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="1f0e1-193">Questa espansione può essere ulteriormente semplificata notando che per qualsiasi numero intero $j $ e un numero reale $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="1f0e1-194">Il motivo è che se si ruota $360 ^ {\circ} $ degrees ($ 2 \ pi $ radianti) in un cerchio, si finisce esattamente nel punto in cui è stato avviato.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="1f0e1-195">L'unica parte importante di $x $ per $e ^ {i2\pi x} $ è quindi la parte frazionaria di $x $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="1f0e1-196">In particolare, se si dispone di un'espansione binaria nel formato $x = y +0. x \_ 0x \_ 2 \ ldots x \_ n $ Then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1})} $ e quindi $ $ \ket{\Phi \_ k (a + b)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi [a/2 ^ k +0. b \_ K\ldots b \_ 1]} \ket {1} \right). $ $ questo significa che se si esegue l'addizione incrementando ognuno dei fattori di tensore nell'espansione della trasformazione di Fourier di $ \ket{a} $, il numero di rotazioni viene compattato come $k $ diminuisce.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="1f0e1-197">In questo modo si riduce notevolmente il numero di controlli Quantum necessari nel Viper.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="1f0e1-198">Si denota la trasformazione di Fourier, l'addizione della fase e i passaggi di trasformazione di Fourier inversa che comprendono il Adder Draper come $ \operatorname{QFT} ^ {-1} \left (\Phi \\ \! \operatorname{Add}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="1f0e1-199">Di seguito è riportato un circuito quantico che usa questa semplificazione per implementare l'intero processo.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Vipera Draper mostrata come diagramma circuito](~/media/draper.svg)

<span data-ttu-id="1f0e1-201">Ogni controllo $e ^ {I2 \ PI/k} $ Gate nel circuito fa riferimento a un gate di fase controllata.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="1f0e1-202">Tali cancelli hanno la proprietà che nella coppia di qubits su cui agiscono, $ \ket {00} \mapsto \ket {00} $ ma $ \ket {11} \mapsto e ^ {I2 \ PI/k} \ KET {11} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="1f0e1-203">Questo circuito consente di eseguire l'addizione senza qubits aggiuntivi, oltre a quelli necessari per archiviare gli input e gli output.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="1f0e1-204">Vipera Beauregard</span><span class="sxs-lookup"><span data-stu-id="1f0e1-204">Beauregard Adder</span></span> ###

<span data-ttu-id="1f0e1-205">Il Adder di Beauregard è un Adder modulare Quantum che usa il Viper di Draper per eseguire il modulo di aggiunta $N $ per un valore integer positivo di valore arbitrario $N $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="1f0e1-206">Il significato dei Viper modulari Quantum, ad esempio la vipera Beauregard, deriva in gran parte dal loro utilizzo nel passaggio modulare di elevamento a potenza nell'algoritmo di Shor per il factoring.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="1f0e1-207">Un Adder modulare Quantum presenta l'azione seguente per l'input Quantum $ \ket{b} $ e l'input classico $a $ in cui $a $ e $b $ sono stati promessi come numeri interi mod $N $, vale a dire che sono nell'intervallo $ [0, \ldots, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="1f0e1-208">$ $ \ket{b}\rightarrow \ket{b + a \Text{mod} N} = \begin{cases} \ket{b + a}, & b + a < N \\ \\ \ket{b + a-N}, & (b + a) \ge n \end{Cases}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="1f0e1-209">Il Adder di Beauregard usa il Adder Draper o più specificamente $ \Phi \\ \! \operatorname{Add} $, per aggiungere $a $ e $b $ in fase.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="1f0e1-210">USA quindi la stessa operazione per determinare se $a + b <N $ sottraendo $N $ e testando se $a + b-N<$0.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="1f0e1-211">Il circuito archivia queste informazioni in un qubit ausiliario e quindi aggiunge $N $ Back The Register se $a + b<N $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="1f0e1-212">Termina quindi con l'annullamento del calcolo di questo bit ausiliario (questo passaggio è necessario per garantire che il ancilla possa essere deallocato dopo la chiamata al Adder).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="1f0e1-213">Di seguito è riportato il circuito per la vipera Beauregard.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-213">The circuit for the Beauregard adder is given below.</span></span>

![Vipera Beauregard mostrata come diagramma circuito](~/media/beau.svg)

<span data-ttu-id="1f0e1-215">Il Gate $ \Phi \\ \! \operatorname{Add} $ ha lo stesso formato di $ \Phi \\ \! \operatorname{Add} $, ad eccezione del fatto che in questo contesto l'input è classico anziché Quantum.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="1f0e1-216">In questo modo, le fasi controllate in $ \Phi \\ \! \operatorname{Add} $ possono essere sostituite con Gate di fase che possono essere compilate insieme in un minor numero di operazioni per ridurre sia il numero di qubits che il numero di porte necessarie per il Viper.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="1f0e1-217">Per altri dettagli, vedere [M. Roetteler, th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) e [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="1f0e1-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="1f0e1-218">Stima delle fasi del calcolo quantistico</span><span class="sxs-lookup"><span data-stu-id="1f0e1-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="1f0e1-219">Un'applicazione particolarmente importante della trasformazione Quantum Fourier consiste nell'apprendere gli autovalori degli operatori unitari, un problema noto come *valutazione della fase*.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="1f0e1-220">Si consideri un $U unitario $ e uno stato $ \ket{\Phi} $ tale che $ \ket{\Phi} $ è un autostato di $U $ con Unknown autovalore $ \Phi $, \begin{Equation} U\ket {\ Phi} = \phi\ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="1f0e1-221">\end{Equation} se si ha accesso solo a $U $ come Oracle, è possibile apprendere la fase $ \Phi $ usando il fatto che $Z $ rotazioni applicate alla destinazione di un'operazione controllata si propagano di nuovo nel controllo.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="1f0e1-222">Si supponga che $V $ sia un'applicazione controllata di $U $, in modo che \begin{align} V (\ket {0} \otimes \ket{\Phi}) & = \ket \otimes \ket{\Phi} \textrm{ {0} \\ \\ e} V (\ket \otimes \ket{\Phi} {1} ) & = e ^ {i \Phi} {1} \ket \otimes \ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="1f0e1-223">\end{align} then, by Linearity, \begin{align} V (\ket{+} \otimes \ket{\Phi}) & = \frac{(\ket {0} \otimes \ket{\Phi}) + e ^ {i \phi} (\ket {1} \otimes \ket{\Phi})} {\sqrt {2} }.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="1f0e1-224">\end{align} è possibile raccogliere i termini per trovare che \begin{align} V (\ket{+} \otimes \ket{\Phi}) & = \frac{\ket {0} + e ^ {i \Phi} \ket {1} } {\sqrt {2} } \otimes \ket{\Phi} \\ \\ & = (R_1 (\Phi) \ket{+}) \otimes \ket{\Phi}, \end{align} dove $R _1 $ è l'unitario applicato dall' <xref:microsoft.quantum.intrinsic.r1> operazione.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="1f0e1-225">Diversamente, l'effetto dell'applicazione di $V $ è esattamente uguale a quello applicato $R _1 $ con un angolo sconosciuto, anche se è possibile accedere solo $V $ come Oracle.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="1f0e1-226">Quindi, nella parte restante di questa discussione verrà discussa la stima della fase in termini di $R _1 (\Phi) $, implementata usando il cosiddetto *contraccolpo della fase*.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="1f0e1-227">Poiché il registro di controllo e di destinazione rimangono invariati dopo questo processo, è possibile riutilizzare $ \ket{\Phi} $ come destinazione di un'applicazione controllata di $U ^ $2 per preparare un secondo controllo qubit nello stato $R _1 (2 \Phi) \ket{+} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="1f0e1-228">Continuando in questo modo, è possibile ottenere un registro nel formato \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \Phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket {0} + \exp (i 2 ^ {j} \Phi) \ket {1} \right) \\ \\ & \propto \ Sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align} dove $n $ è il numero di bit di precisione necessari, e dove abbiamo usato $ {} \propto {} $ per indicare che è stato eliminato il fattore di normalizzazione di $1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="1f0e1-229">Se si presuppone che $ \Phi = 2 \Pi p/2 ^ k $ per un numero intero $p $, questo viene riconosciuto come $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, dove $p _J $ è il $j ^ {\textrm{TH}} $ bit di $2 \Pi \Phi $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="1f0e1-230">Se si applica l'oggetto contiguo della trasformazione Quantum Fourier, viene pertanto ottenuta la rappresentazione binaria della fase codificata come stato quantum.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="1f0e1-231">In Q # questo viene implementato dall' <xref:microsoft.quantum.characterization.quantumphaseestimation> operazione, che accetta un' <xref:microsoft.quantum.oracles.discreteoracle> applicazione di implementazione di $U ^ m $ come funzione di numeri interi positivi $m $.</span><span class="sxs-lookup"><span data-stu-id="1f0e1-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
