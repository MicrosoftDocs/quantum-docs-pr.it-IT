---
title: Operazioni e funzioni intrinseche in QDK
description: Informazioni sulle funzioni e le funzioni intrinseche in QDK, incluse le funzioni classiche e le operazioni Unity, di rotazione e di misurazione.
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.prelude
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 4d15226fe46be79b7d3e6f414f33f1debd691f40
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692122"
---
# <a name="the-prelude"></a><span data-ttu-id="8dd0e-103">Preludio</span><span class="sxs-lookup"><span data-stu-id="8dd0e-103">The Prelude</span></span> #

<span data-ttu-id="8dd0e-104">Il :::no-loc(Q#)::: compilatore e i computer di destinazione inclusi in Quantum Development Kit forniscono un set di funzioni intrinseche e operazioni che possono essere usate durante la scrittura di programmi Quantum in :::no-loc(Q#)::: .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-104">The :::no-loc(Q#)::: compiler and the target machines included with the Quantum Development Kit provide a set of intrinsic functions and operations that can be used when writing quantum programs in :::no-loc(Q#):::.</span></span>

## <a name="intrinsic-operations-and-functions"></a><span data-ttu-id="8dd0e-105">Operazioni e funzioni intrinseche</span><span class="sxs-lookup"><span data-stu-id="8dd0e-105">Intrinsic Operations and Functions</span></span> ##

<span data-ttu-id="8dd0e-106">Le operazioni intrinseche definite nella libreria standard rientrano approssimativamente in una delle categorie seguenti:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-106">The intrinsic operations defined in the standard library roughly fall into one of several categories:</span></span>

- <span data-ttu-id="8dd0e-107">Funzioni classiche essenziali, raccolte nello <xref:Microsoft.Quantum.Core> spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-107">Essential classical functions, collected in the <xref:Microsoft.Quantum.Core> namespace.</span></span>
- <span data-ttu-id="8dd0e-108">Operazioni che rappresentano unitaries composte da [Clifford e $T $ Gates](xref:microsoft.quantum.concepts.qubit).</span><span class="sxs-lookup"><span data-stu-id="8dd0e-108">Operations representing unitaries composed of [Clifford and $T$ gates](xref:microsoft.quantum.concepts.qubit).</span></span>
- <span data-ttu-id="8dd0e-109">Operazioni che rappresentano le rotazioni relative a vari operatori.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-109">Operations representing rotations about various operators.</span></span>
- <span data-ttu-id="8dd0e-110">Operazioni di implementazione delle misure.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-110">Operations implementing measurements.</span></span>

<span data-ttu-id="8dd0e-111">Dato che il set di Gate di Clifford + $T $ è [universale](xref:microsoft.quantum.concepts.multiple-qubits) per quantum computing, queste operazioni sono sufficienti per implementare qualsiasi algoritmo Quantum in un errore trascurabile di piccole dimensioni.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-111">Since the Clifford + $T$ gate set is [universal](xref:microsoft.quantum.concepts.multiple-qubits) for quantum computing, these operations suffice to approximately implement any quantum algorithm within negligibly small error.</span></span>
<span data-ttu-id="8dd0e-112">Fornendo anche le rotazioni, :::no-loc(Q#)::: consente al programmatore di lavorare all'interno della singola libreria qubit Unity e CNOT Gate.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-112">By providing rotations as well, :::no-loc(Q#)::: allows the programmer to work within the single qubit unitary and CNOT gate library.</span></span> <span data-ttu-id="8dd0e-113">Questa libreria è molto più semplice da considerare perché non richiede al programmatore di esprimere direttamente la decomposizione di Clifford + $T $ e perché esistono metodi estremamente efficienti per la compilazione di singoli qubit unitaries in Clifford e $T $ Gates (vedere [qui](xref:microsoft.quantum.more-information) per altre informazioni).</span><span class="sxs-lookup"><span data-stu-id="8dd0e-113">This library is much easier to think about because it does not  require the programmer to directly express the Clifford + $T$ decomposition and because highly efficient methods exist for compiling single qubit unitaries into Clifford and $T$ gates (see [here](xref:microsoft.quantum.more-information) for more information).</span></span>

<span data-ttu-id="8dd0e-114">Laddove possibile, le operazioni definite nel preludio che agiscono su qubits consentono di applicare la `Controlled` variante, in modo che il computer di destinazione esegua la scomposizione appropriata.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-114">Where possible, the operations defined in the prelude which act on qubits allow for applying the `Controlled` variant, such that the target machine will perform the appropriate decomposition.</span></span>

<span data-ttu-id="8dd0e-115">Molte funzioni e operazioni definite in questa parte del preludio sono nello @"microsoft.quantum.intrinsic" spazio dei nomi, in modo che la maggior parte dei :::no-loc(Q#)::: file di origine disponga di una `open Microsoft.Quantum.Intrinsic;` direttiva che segue immediatamente la dichiarazione dello spazio dei nomi iniziale.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-115">Many of the functions and operations defined in this portion of the prelude are in the @"microsoft.quantum.intrinsic" namespace, such that most :::no-loc(Q#)::: source files will have an `open Microsoft.Quantum.Intrinsic;` directive immediately following the initial namespace declaration.</span></span>
<span data-ttu-id="8dd0e-116">Lo <xref:Microsoft.Quantum.Core> spazio dei nomi viene aperto automaticamente, in modo che funzioni come <xref:Microsoft.Quantum.Core.Length> possono essere usate senza un' `open` istruzione.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-116">The <xref:Microsoft.Quantum.Core> namespace is automatically opened, so that functions such as <xref:Microsoft.Quantum.Core.Length> can be used without an `open` statement at all.</span></span>

### <a name="common-single-qubit-unitary-operations"></a><span data-ttu-id="8dd0e-117">Operazioni comuni di Single-Qubit Unity</span><span class="sxs-lookup"><span data-stu-id="8dd0e-117">Common Single-Qubit Unitary Operations</span></span> ###

<span data-ttu-id="8dd0e-118">Il preludio definisce anche molte [operazioni comuni a qubit singola](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span><span class="sxs-lookup"><span data-stu-id="8dd0e-118">The prelude also defines many common [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span></span>
<span data-ttu-id="8dd0e-119">Tutte queste operazioni consentono sia `Controlled` a che a `Adjoint` funtori.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-119">All of these operations allow both the `Controlled` and `Adjoint` functors.</span></span>

#### <a name="pauli-operators"></a><span data-ttu-id="8dd0e-120">Operatori Pauli</span><span class="sxs-lookup"><span data-stu-id="8dd0e-120">Pauli Operators</span></span> ####

<span data-ttu-id="8dd0e-121">L' <xref:Microsoft.Quantum.Intrinsic.X> operazione implementa l'operatore Pauli $X $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-121">The <xref:Microsoft.Quantum.Intrinsic.X> operation implements the Pauli $X$ operator.</span></span>
<span data-ttu-id="8dd0e-122">Questa operazione è talvolta nota anche come controllo `NOT` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-122">This is sometimes also known as the `NOT` gate.</span></span>
<span data-ttu-id="8dd0e-123">Dispone della firma `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-123">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-124">Corrisponde al gruppo qubit singolo:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-124">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="8dd0e-125">\begin{Equation} \begin{Bmatrix} 0 & 1 \\ \\ % FIXME: attualmente usa il quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-125">\begin{equation} \begin{bmatrix} 0 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="8dd0e-126">1 & 0 \end{Bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="8dd0e-126">1 & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="8dd0e-127">L' <xref:Microsoft.Quantum.Intrinsic.Y> operazione implementa l'operatore Pauli $Y $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-127">The <xref:Microsoft.Quantum.Intrinsic.Y> operation implements the Pauli $Y$ operator.</span></span>
<span data-ttu-id="8dd0e-128">Dispone della firma `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-128">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-129">Corrisponde al gruppo qubit singolo:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-129">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="8dd0e-130">\begin{Equation} \begin{Bmatrix} 0 &-i \\ \\ % FIXME: attualmente usa il quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-130">\begin{equation} \begin{bmatrix} 0 & -i \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="8dd0e-131">i & 0 \end{Bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="8dd0e-131">i & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="8dd0e-132">L' <xref:Microsoft.Quantum.Intrinsic.Z> operazione implementa l'operatore Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-132">The <xref:Microsoft.Quantum.Intrinsic.Z> operation implements the Pauli $Z$ operator.</span></span>
<span data-ttu-id="8dd0e-133">Dispone della firma `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-133">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-134">Corrisponde al gruppo qubit singolo:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-134">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="8dd0e-135">\begin{Equation} \begin{Bmatrix} 1 & 0 \\ \\ % FIXME: attualmente usa il quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-135">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="8dd0e-136">0 &-1 \end{Bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="8dd0e-136">0 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="8dd0e-137">Di seguito sono riportate le trasformazioni di cui è stato eseguito il mapping alla [sfera Bloch](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (l'asse di rotazione in ogni case è evidenziato in rosso):</span><span class="sxs-lookup"><span data-stu-id="8dd0e-137">Below we see these transformations mapped to the [Bloch sphere](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (the rotation axis in each case is highlighted red):</span></span>

![Operazioni di Pauli mappate nella sfera Bloch](~/media/prelude_pauliBloch.png)

<span data-ttu-id="8dd0e-139">È importante notare che l'applicazione dello stesso controllo Pauli due volte allo stesso qubit Annulla l'operazione (poiché a questo punto è stata eseguita una rotazione completa di 2 π (360 °) sulla superficie di Bloch, in modo da tornare al punto di partenza.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-139">It is important to note that applying the same Pauli gate twice to the same qubit cancels out the operation (because you have now performed a full rotation of 2π (360°) over the surface to the Bloch Sphere, thus arriving back at the starting point).</span></span> <span data-ttu-id="8dd0e-140">Viene visualizzata la seguente identità:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-140">This brings us to the following identity:</span></span>

<span data-ttu-id="8dd0e-141">$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \boldone $ $</span><span class="sxs-lookup"><span data-stu-id="8dd0e-141">$$ X^2=Y^2=Z^2=\boldone $$</span></span>

<span data-ttu-id="8dd0e-142">Questo può essere visualizzato nella sfera Bloch:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-142">This can be visualised on the Bloch sphere:</span></span>

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a><span data-ttu-id="8dd0e-144">Altri Single-Qubit Cliffords</span><span class="sxs-lookup"><span data-stu-id="8dd0e-144">Other Single-Qubit Cliffords</span></span> ####

<span data-ttu-id="8dd0e-145">L' <xref:Microsoft.Quantum.Intrinsic.H> operazione implementa il controllo Hadamard.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-145">The <xref:Microsoft.Quantum.Intrinsic.H> operation implements the Hadamard gate.</span></span>
<span data-ttu-id="8dd0e-146">Questo scambia gli assi Pauli $X $ e $Z $ della qubit di destinazione, in modo che $H \ket {0} = \ket{+} \mathrel{: =} (\ket {0} + \ket {1} )/\sqrt {2} $ e $H \ket{+} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-146">This interchanges the Pauli $X$ and $Z$ axes of the target qubit, such that $H\ket{0} = \ket{+} \mathrel{:=} (\ket{0} + \ket{1}) / \sqrt{2}$ and $H\ket{+} = \ket{0}$.</span></span>
<span data-ttu-id="8dd0e-147">Ha la firma `(Qubit => Unit is Adj + Ctl)` e corrisponde all'unità qubit singolo:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-147">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="8dd0e-148">\begin{Equation} \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ % FIXME: attualmente usa la quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-148">\begin{equation} \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="8dd0e-149">1 &-1 \end{Bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="8dd0e-149">1 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="8dd0e-150">Il controllo Hadamard è particolarmente importante perché può essere usato per creare una superposizione degli Stati $ \ket {0} $ e $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-150">The Hadamard gate is particularly important as it can be used to create a superposition of the $\ket{0}$ and $\ket{1}$ states.</span></span> <span data-ttu-id="8dd0e-151">Nella rappresentazione di Sphere di Bloch, è più facile pensare a questo come una rotazione di $ \ket{\psi} $ attorno all'asse x di $ \Pi $ radianti ($ 180 ^ \circ $) seguita da una rotazione (in senso orario) intorno all'asse y di $ \ PI/2 $ radianti ($ 90 ^ \circ $):</span><span class="sxs-lookup"><span data-stu-id="8dd0e-151">In the Bloch sphere representation, it is easiest to think of this as a rotation of $\ket{\psi}$ around the x-axis by $\pi$ radians ($180^\circ$) followed by a (clockwise) rotation around the y-axis by $\pi/2$ radians ($90^\circ$):</span></span>

![Operazione Hadamard mappata nella sfera Bloch](~/media/prelude_hadamardBloch.png)

<span data-ttu-id="8dd0e-153">L' <xref:Microsoft.Quantum.Intrinsic.S> operazione implementa la fase gate $S $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-153">The <xref:Microsoft.Quantum.Intrinsic.S> operation implements the phase gate $S$.</span></span>
<span data-ttu-id="8dd0e-154">Si tratta della radice quadrata della matrice dell'operazione Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-154">This is the matrix square root of the Pauli $Z$ operation.</span></span>
<span data-ttu-id="8dd0e-155">Ovvero $S ^ 2 = Z $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-155">That is, $S^2 = Z$.</span></span>
<span data-ttu-id="8dd0e-156">Ha la firma `(Qubit => Unit is Adj + Ctl)` e corrisponde all'unità qubit singolo:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-156">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="8dd0e-157">\begin{Equation} \begin{Bmatrix} 1 & 0 \\ \\ % FIXME: attualmente usa il quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-157">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="8dd0e-158">0 & \end{Bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="8dd0e-158">0 & i \end{bmatrix} \end{equation}</span></span>

#### <a name="rotations"></a><span data-ttu-id="8dd0e-159">Rotazioni</span><span class="sxs-lookup"><span data-stu-id="8dd0e-159">Rotations</span></span> ####

<span data-ttu-id="8dd0e-160">Oltre alle operazioni di Pauli e Clifford precedenti, il :::no-loc(Q#)::: preludio offre un'ampia gamma di modi per esprimere le rotazioni.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-160">In addition to the Pauli and Clifford operations above, the :::no-loc(Q#)::: prelude provides a variety of ways of expressing rotations.</span></span>
<span data-ttu-id="8dd0e-161">Come descritto in [operazioni Single-qubit](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), la possibilità di ruotare è fondamentale per gli algoritmi Quantum.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-161">As described in [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), the ability to rotate is critical to quantum algorithms.</span></span>

<span data-ttu-id="8dd0e-162">Si inizia richiamando che è possibile esprimere qualsiasi operazione Single-qubit usando il $H $ e $T $ Gates, dove $H $ è l'operazione Hadamard e dove \begin{Equation} T \mathrel{: =} \begin{Bmatrix} 1 & 0 \\ \\ % FIXME: attualmente usa il quad back Whack hack.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-162">We start by recalling that we can express any single-qubit operation using the $H$ and $T$ gates, where $H$ is the Hadamard operation, and where \begin{equation} T \mathrel{:=} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quad back whack hack.</span></span>
<span data-ttu-id="8dd0e-163">0 & e ^ {i \Pi/4} \end{Bmatrix} \end{Equation} questa è la radice quadrata dell' <xref:Microsoft.Quantum.Intrinsic.S> operazione, in modo che $T ^ 2 = S $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-163">0 & e^{i \pi / 4} \end{bmatrix} \end{equation} This is the square root of the <xref:Microsoft.Quantum.Intrinsic.S> operation, such that $T^2 = S$.</span></span>
<span data-ttu-id="8dd0e-164">Il $T $ Gate viene a sua volta implementato dall' <xref:Microsoft.Quantum.Intrinsic.T> operazione e ha la firma `(Qubit => Unit is Adj + Ctl)` , a indicare che si tratta di un'operazione unitaria su un singolo qubit.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-164">The $T$ gate is in turn implemented by the <xref:Microsoft.Quantum.Intrinsic.T> operation, and has signature `(Qubit => Unit is Adj + Ctl)`, indicating that it is a unitary operation on a single-qubit.</span></span>

<span data-ttu-id="8dd0e-165">Anche se questo è fondamentalmente sufficiente per descrivere qualsiasi operazione arbitraria a singolo qubit, i computer di destinazione diversi possono avere rappresentazioni più efficienti per le rotazioni sugli operatori di Pauli, in modo che il preludio includa diversi modi per convienently esprimere tali rotazioni.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-165">Even though this is in principle sufficient to describe any arbitrary single-qubit operation, different target machines may have more efficient representations for rotations about Pauli operators, such that the prelude includes a variety of ways to convienently express such rotations.</span></span>
<span data-ttu-id="8dd0e-166">Il più semplice di questi è l' <xref:Microsoft.Quantum.Intrinsic.r> operazione, che implementa una rotazione intorno a un asse di Pauli specificato, \Begin{Equation} R (\sigma, \Phi) \mathrel{: =} \exp (-i \Phi \sigma/2), \end{Equation} dove $ \sigma $ è un operatore Pauli, $ \Phi $ è un angolo e dove $ \exp $ rappresenta la matrice esponenziale.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-166">The most basic of these is the <xref:Microsoft.Quantum.Intrinsic.r> operation, which implements a rotation around a specified Pauli axis, \begin{equation} R(\sigma, \phi) \mathrel{:=} \exp(-i \phi \sigma / 2), \end{equation} where $\sigma$ is a Pauli operator, $\phi$ is an angle, and where $\exp$ represents the matrix exponential.</span></span>
<span data-ttu-id="8dd0e-167">Dispone della firma `((Pauli, Double, Qubit) => Unit is Adj + Ctl)` , in cui le prime due parti dell'input rappresentano gli argomenti classici $ \sigma $ e $ \Phi $ necessari per specificare l'operatore unitario $R (\sigma, \Phi) $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-167">It has signature `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`, where the first two parts of the input represent the classical arguments $\sigma$ and $\phi$ needed to specify the unitary operator $R(\sigma, \phi)$.</span></span>
<span data-ttu-id="8dd0e-168">È possibile applicare parzialmente $ \sigma $ e $ \Phi $ per ottenere un'operazione il cui tipo è quello di un singolo unità qubit.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-168">We can partially apply $\sigma$ and $\phi$ to obtain an operation whose type is that of a single-qubit unitary.</span></span>
<span data-ttu-id="8dd0e-169">Ad esempio, `R(PauliZ, PI() / 4, _)` è di tipo `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-169">For example, `R(PauliZ, PI() / 4, _)` has type `(Qubit => Unit is Adj + Ctl)`.</span></span>

> [!NOTE]
> <span data-ttu-id="8dd0e-170">L' <xref:Microsoft.Quantum.Intrinsic.r> operazione divide l'angolo di input di 2 e la moltiplica per-1.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-170">The <xref:Microsoft.Quantum.Intrinsic.r> operation divides the input angle by 2 and multiplies it by -1.</span></span>
> <span data-ttu-id="8dd0e-171">Per $Z $ rotations, significa che $ \ket {0} $ autostato è ruotato da $-\Phi/$2 e $ \ket {1} $ autostato viene ruotato da $ \phi/$2, in modo che $ \ket {1} $ autostato venga ruotato di $ \Phi $ relativo a $ \ket $ autostato {0} .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-171">For $Z$ rotations, this means that the $\ket{0}$ eigenstate is rotated by $-\phi / 2$ and the $\ket{1}$ eigenstate is rotated by $\phi / 2$, so that the $\ket{1}$ eigenstate is rotated by $\phi$ relative to the $\ket{0}$ eigenstate.</span></span>
>
> <span data-ttu-id="8dd0e-172">In particolare, ciò significa che `T` e `R(PauliZ, PI() / 8, _)` differiscono solo per una [fase globale](xref:microsoft.quantum.glossary#global-phase)irrilevante.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-172">In particular, this means that `T` and `R(PauliZ, PI() / 8, _)` differ only by an irrelevant [global phase](xref:microsoft.quantum.glossary#global-phase).</span></span>
> <span data-ttu-id="8dd0e-173">Per questo motivo, $T $ è talvolta noto come $ \frac{\Pi} {8} $-Gate.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-173">For this reason, $T$ is sometimes known as the $\frac{\pi}{8}$-gate.</span></span>
>
> <span data-ttu-id="8dd0e-174">Si noti anche che la rotazione intorno `PauliI` a applica semplicemente una fase globale di $ \Phi/$2.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-174">Note also that rotating around `PauliI` simply applies a global phase of $\phi / 2$.</span></span> <span data-ttu-id="8dd0e-175">Sebbene tali fasi siano irrilevanti, come affermato nei [documenti concettuali](xref:microsoft.quantum.concepts.qubit), sono rilevanti per le `PauliI` rotazioni controllate.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-175">While such phases are irrelevant, as argued in [the conceptual documents](xref:microsoft.quantum.concepts.qubit), they are relevant for controlled `PauliI` rotations.</span></span>

<span data-ttu-id="8dd0e-176">Negli algoritmi quantistici è spesso utile esprimere le rotazioni come frazioni diadico, in modo che $ \Phi = \Pi k/2 ^ n $ per alcuni $k \in \mathbb{Z} $ e $n \in \mathbb{N} $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-176">Within quantum algorithms, it is often useful to express rotations as dyadic fractions, such that $\phi = \pi k / 2^n$ for some $k \in \mathbb{Z}$ and $n \in \mathbb{N}$.</span></span>
<span data-ttu-id="8dd0e-177">L' <xref:Microsoft.Quantum.Intrinsic.RFrac> operazione implementa una rotazione intorno a un asse di Pauli specificato utilizzando questa convenzione.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-177">The <xref:Microsoft.Quantum.Intrinsic.RFrac> operation implements a rotation around a specified Pauli axis using this convention.</span></span>
<span data-ttu-id="8dd0e-178">Si differenzia da <xref:Microsoft.Quantum.Intrinsic.R> in quanto l'angolo di rotazione viene specificato come due input di tipo `Int` , interpretato come una frazione diadico.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-178">It differs from <xref:Microsoft.Quantum.Intrinsic.R> in that the rotation angle is specified as two inputs of type `Int`, interpreted as a dyadic fraction.</span></span>
<span data-ttu-id="8dd0e-179">Dispone pertanto della `RFrac` firma `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-179">Thus, `RFrac` has signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-180">Implementa il singolo qubit Unity $ \exp (i \Pi k \sigma/2 ^ n) $, dove $ \sigma $ è la matrice di Pauli corrispondente al primo argomento, $k $ è il secondo argomento e $n $ è il terzo argomento.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-180">It implements the single-qubit unitary $\exp(i \pi k \sigma / 2^n)$, where $\sigma$ is the Pauli matrix corresponding to the first argument, $k$ is the second argument, and $n$ is the third argument.</span></span>
<span data-ttu-id="8dd0e-181">`RFrac(_,k,n,_)` è uguale a. si `R(_,-πk/2^n,_)` noti che l'angolo è il *negativo* della frazione.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-181">`RFrac(_,k,n,_)` is the same as `R(_,-πk/2^n,_)`; note that the angle is the *negative* of the fraction.</span></span>

<span data-ttu-id="8dd0e-182">L' <xref:Microsoft.Quantum.Intrinsic.Rx> operazione implementa una rotazione intorno all'asse di Pauli $X $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-182">The <xref:Microsoft.Quantum.Intrinsic.Rx> operation implements a rotation around the Pauli $X$ axis.</span></span>
<span data-ttu-id="8dd0e-183">Dispone della firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-183">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-184">`Rx(_, _)` è uguale a `R(PauliX, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-184">`Rx(_, _)` is the same as `R(PauliX, _, _)`.</span></span>

<span data-ttu-id="8dd0e-185">L' <xref:Microsoft.Quantum.Intrinsic.Ry> operazione implementa una rotazione intorno all'asse di Pauli $Y $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-185">The <xref:Microsoft.Quantum.Intrinsic.Ry> operation implements a rotation around the Pauli $Y$ axis.</span></span>
<span data-ttu-id="8dd0e-186">Dispone della firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-186">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-187">`Ry(_, _)` è uguale a `R(PauliY,_ , _)`.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-187">`Ry(_, _)` is the same as `R(PauliY,_ , _)`.</span></span>

<span data-ttu-id="8dd0e-188">L' <xref:Microsoft.Quantum.Intrinsic.Rz> operazione implementa una rotazione intorno all'asse di Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-188">The <xref:Microsoft.Quantum.Intrinsic.Rz> operation implements a rotation around the Pauli $Z$ axis.</span></span>
<span data-ttu-id="8dd0e-189">Dispone della firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-189">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-190">`Rz(_, _)` è uguale a `R(PauliZ, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-190">`Rz(_, _)` is the same as `R(PauliZ, _, _)`.</span></span>

<span data-ttu-id="8dd0e-191">L' <xref:Microsoft.Quantum.Intrinsic.R1> operazione implementa una rotazione in base alla quantità specificata circa $ \ket {1} $, il autostato $-$1 di $Z $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-191">The <xref:Microsoft.Quantum.Intrinsic.R1> operation implements a rotation by the given amount around $\ket{1}$, the $-1$ eigenstate of $Z$.</span></span>
<span data-ttu-id="8dd0e-192">Dispone della firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-192">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-193">`R1(phi,_)` è uguale a `R(PauliZ,phi,_)` seguito da `R(PauliI,-phi,_)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-193">`R1(phi,_)` is the same as `R(PauliZ,phi,_)` followed by `R(PauliI,-phi,_)`.</span></span>

<span data-ttu-id="8dd0e-194">L' <xref:Microsoft.Quantum.Intrinsic.R1Frac> operazione implementa una rotazione frazionaria in base alla quantità specificata intorno alla Z = 1 autostato.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-194">The <xref:Microsoft.Quantum.Intrinsic.R1Frac> operation implements a fractional rotation by the given amount around the Z=1 eigenstate.</span></span>
<span data-ttu-id="8dd0e-195">Dispone della firma `((Int,Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-195">It has signature `((Int,Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-196">`R1Frac(k,n,_)` è uguale a `RFrac(PauliZ,-k.n+1,_)` seguito da `RFrac(PauliI,k,n+1,_)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-196">`R1Frac(k,n,_)` is the same as `RFrac(PauliZ,-k.n+1,_)` followed by `RFrac(PauliI,k,n+1,_)`.</span></span>

<span data-ttu-id="8dd0e-197">Di seguito è riportato un esempio di un'operazione di rotazione (intorno all'asse Pauli $Z $, in questa istanza) mappato alla sfera Bloch:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-197">An example of a rotation operation (around the Pauli $Z$ axis, in this instance) mapped onto the Bloch sphere is shown below:</span></span>

![Operazione di rotazione mappata nella sfera Bloch](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a><span data-ttu-id="8dd0e-199">Operazioni qubit</span><span class="sxs-lookup"><span data-stu-id="8dd0e-199">Multi-Qubit Operations</span></span> ####

<span data-ttu-id="8dd0e-200">Oltre alle operazioni Single-qubit precedenti, il preludio definisce anche diverse operazioni multiqubit.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-200">In addition to the single-qubit operations above, the prelude also defines several multi-qubit operations.</span></span>

<span data-ttu-id="8dd0e-201">Per prima cosa, l' <xref:Microsoft.Quantum.Intrinsic.CNOT> operazione esegue un controllo- `NOT` Gate standard, \begin{Equation} \operatorname{CNOT} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \\ \\ 0 & 0 & 1 & 0 \end{Bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-201">First, the <xref:Microsoft.Quantum.Intrinsic.CNOT> operation performs a standard controlled-`NOT` gate, \begin{equation} \operatorname{CNOT} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \end{bmatrix}.</span></span>
<span data-ttu-id="8dd0e-202">\end{Equation} dispone della firma `((Qubit, Qubit) => Unit is Adj + Ctl)` , che rappresenta che $ \operatorname{CNOT} $ agisce unitarily su due qubits singoli.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-202">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`, representing that $\operatorname{CNOT}$ acts unitarily on two individual qubits.</span></span>
<span data-ttu-id="8dd0e-203">`CNOT(q1, q2)` è uguale a `(Controlled X)([q1], q2)`.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-203">`CNOT(q1, q2)` is the same as `(Controlled X)([q1], q2)`.</span></span>
<span data-ttu-id="8dd0e-204">Poiché il `Controlled` functor consente il controllo in un registro, viene usato il valore letterale `[q1]` di matrice per indicare che si vuole solo il controllo.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-204">Since the `Controlled` functor allows for controlling on a register, we use the array literal `[q1]` to indicate that we want only the one control.</span></span>

<span data-ttu-id="8dd0e-205">L' <xref:Microsoft.Quantum.Intrinsic.CCNOT> operazione esegue il controllo non gestito doppiamente, talvolta noto anche come Toffoli Gate.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-205">The <xref:Microsoft.Quantum.Intrinsic.CCNOT> operation performs doubly-controlled NOT gate, sometimes also known as the Toffoli gate.</span></span>
<span data-ttu-id="8dd0e-206">Dispone della firma `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-206">It has signature `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-207">`CCNOT(q1, q2, q3)` è uguale a `(Controlled X)([q1, q2], q3)`.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-207">`CCNOT(q1, q2, q3)` is the same as `(Controlled X)([q1, q2], q3)`.</span></span>

<span data-ttu-id="8dd0e-208">L' <xref:Microsoft.Quantum.Intrinsic.SWAP> operazione scambia gli Stati del quantum di due qubits.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-208">The <xref:Microsoft.Quantum.Intrinsic.SWAP> operation swaps the quantum states of two qubits.</span></span>
<span data-ttu-id="8dd0e-209">Ovvero implementa la matrice unitaria \begin{Equation} \operatorname{SWAP} \mathrel{: =} \begin{Bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 0 & 1 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \end{Bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-209">That is, it implements the unitary matrix \begin{equation} \operatorname{SWAP} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}.</span></span>
<span data-ttu-id="8dd0e-210">\end{Equation} dispone della firma `((Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-210">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="8dd0e-211">`SWAP(q1,q2)` equivale a `CNOT(q1, q2)` seguito da `CNOT(q2, q1)` e quindi da `CNOT(q1, q2)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-211">`SWAP(q1,q2)` is equivalent to `CNOT(q1, q2)` followed by `CNOT(q2, q1)` and then `CNOT(q1, q2)`.</span></span>

> [!NOTE]
> <span data-ttu-id="8dd0e-212">Lo scambio *non* corrisponde alla ridisposizione degli elementi di una variabile di tipo `Qubit[]` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-212">The SWAP gate is *not* the same as rearranging the elements of a variable with type `Qubit[]`.</span></span>
> <span data-ttu-id="8dd0e-213">Se si applica, viene apportata `SWAP(q1, q2)` una modifica allo stato di qubits a cui fa riferimento `q1` e `q2` , mentre `let swappedRegister = [q2, q1];` influiscono solo sul modo in cui si fa riferimento a tali qubits.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-213">Applying `SWAP(q1, q2)` causes a change to the state of the qubits referred to by `q1` and `q2`, while `let swappedRegister = [q2, q1];` only affects how we refer to those qubits.</span></span>
> <span data-ttu-id="8dd0e-214">Consente inoltre `(Controlled SWAP)([q0], (q1, q2))` `SWAP` di condizionare lo stato di un terzo qubit, che non è possibile rappresentare ridisponendo gli elementi.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-214">Moreover, `(Controlled SWAP)([q0], (q1, q2))` allows for `SWAP` to be conditioned on the state of a third qubit, which we cannot represent by rearranging elements.</span></span>
> <span data-ttu-id="8dd0e-215">Il Gate di scambio controllato, noto anche come Fredkin Gate, è sufficientemente potente da includere tutti i calcoli classici.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-215">The controlled-SWAP gate, also known as the Fredkin gate, is powerful enough to include all classical computation.</span></span>

<span data-ttu-id="8dd0e-216">Infine, il preludio fornisce due operazioni per la rappresentazione esponenziale degli operatori qubit di Pauli.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-216">Finally, the prelude provides two operations for representing exponentials of multi-qubit Pauli operators.</span></span>
<span data-ttu-id="8dd0e-217">L' <xref:Microsoft.Quantum.Intrinsic.Exp> operazione esegue una rotazione basata su un prodotto tensore di matrici Pauli, come rappresentato dall'unità qubit \Begin{Equation} \operatorname{exp} (\vec{\sigma}, \Phi) \mathrel{: =} \exp\left (i \phi sigma_0 \otimes \ sigma_1 \otimes \cdots \otimes \ sigma_n \right), \end{Equation} in cui $ \vec{\sigma} = (\ sigma_0, \ sigma_1, \dots, \ sigma_n) $ è una sequenza di operatori di sola qubit Pauli e dove $ \Phi $ è un angolo.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-217">The <xref:Microsoft.Quantum.Intrinsic.Exp> operation performs a rotation based on a tensor product of Pauli matrices, as represented by the multi-qubit unitary \begin{equation} \operatorname{Exp}(\vec{\sigma}, \phi) \mathrel{:=} \exp\left(i \phi \sigma_0 \otimes \sigma_1 \otimes \cdots \otimes \sigma_n \right), \end{equation} where $\vec{\sigma} = (\sigma_0, \sigma_1, \dots, \sigma_n)$ is a sequence of single-qubit Pauli operators, and where $\phi$ is an angle.</span></span>
<span data-ttu-id="8dd0e-218">La `Exp` rotazione rappresenta $ \vec{\sigma} $ come matrice di `Pauli` elementi, in modo che disponga della firma `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-218">The `Exp` rotation represents $\vec{\sigma}$ as an array of `Pauli` elements, such that it has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="8dd0e-219">L' <xref:Microsoft.Quantum.Intrinsic.ExpFrac> operazione esegue la stessa rotazione, usando la notazione della frazione diadico descritta in precedenza.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-219">The <xref:Microsoft.Quantum.Intrinsic.ExpFrac> operation performs the same rotation, using the dyadic fraction notation discussed above.</span></span>
<span data-ttu-id="8dd0e-220">Dispone della firma `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-220">It has signature `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

> [!WARNING]
> <span data-ttu-id="8dd0e-221">Gli esponenziali del prodotto tensore degli operatori di Pauli non sono uguali ai prodotti tensori delle esponenziali degli operatori Pauli.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-221">Exponentials of the tensor product of Pauli operators are not the same as tensor products of the exponentials of Pauli operators.</span></span>
> <span data-ttu-id="8dd0e-222">Ovvero $e ^ {i (Z \otimes Z) \Phi} \ne e ^ {i Z \Phi} \otimes e ^ {i Z \Phi} $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-222">That is, $e^{i (Z \otimes Z) \phi} \ne e^{i Z \phi} \otimes e^{i Z \phi}$.</span></span>

### <a name="measurements"></a><span data-ttu-id="8dd0e-223">Misurazioni</span><span class="sxs-lookup"><span data-stu-id="8dd0e-223">Measurements</span></span> ###

<span data-ttu-id="8dd0e-224">Quando si esegue la misurazione, il valore + 1 autovalore dell'operatore da misurare corrisponde a un `Zero` risultato e il valore-1 autovalore a un `One` risultato.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-224">When measuring, the +1 eigenvalue of the operator being measured corresponds to a `Zero` result, and the -1 eigenvalue to a `One` result.</span></span>

> [!NOTE]
> <span data-ttu-id="8dd0e-225">Sebbene la Convenzione possa sembrare dispari, presenta due vantaggi molto interessanti.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-225">While this convention might seem odd, it has two very nice advantages.</span></span>
> <span data-ttu-id="8dd0e-226">Per prima cosa, l'osservazione del risultato $ \ket {0} $ è rappresentata dal `Result` valore `Zero` , mentre l'osservazione {1} di $ \ket $ corrisponde a `One` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-226">First, observing the outcome $\ket{0}$ is represented by the `Result` value `Zero`, while observing $\ket{1}$ corresponds to `One`.</span></span>
> <span data-ttu-id="8dd0e-227">In secondo luogo, è possibile scrivere che autovalore $ \lambda $ corrispondente a un risultato $r $ is $ \lambda = (-1) ^ r $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-227">Second, we can write out that the eigenvalue $\lambda$ corresponding to a result $r$ is $\lambda = (-1)^r$.</span></span>

<span data-ttu-id="8dd0e-228">Le operazioni di misurazione supportano né né il `Adjoint` `Controlled` functore.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-228">Measurement operations support neither the `Adjoint` nor the `Controlled` functor.</span></span>

<span data-ttu-id="8dd0e-229">L' <xref:Microsoft.Quantum.Intrinsic.Measure> operazione esegue una misurazione congiunta di uno o più qubits nel prodotto specificato di operatori Pauli.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-229">The <xref:Microsoft.Quantum.Intrinsic.Measure> operation performs a joint measurement of one or more qubits in the specified product of Pauli operators.</span></span>
<span data-ttu-id="8dd0e-230">Se la matrice di Pauli e la matrice qubit hanno lunghezze diverse, l'operazione ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-230">If the Pauli array and qubit array are different lengths, then the operation fails.</span></span>
<span data-ttu-id="8dd0e-231">`Measure` dispone della firma `((Pauli[], Qubit[]) => Result)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-231">`Measure` has signature `((Pauli[], Qubit[]) => Result)`.</span></span>

<span data-ttu-id="8dd0e-232">Si noti che una misurazione congiunta non corrisponde alla misurazione di ogni singolo qubit.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-232">Note that a joint measurement is not the same as measuring each qubit individually.</span></span>
<span data-ttu-id="8dd0e-233">Si consideri ad esempio lo stato $ \ket {11} = \ket {1} \otimes \Ket {1} = X\otimes X \ket {00} $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-233">For example, consider the state $\ket{11} = \ket{1} \otimes \ket{1} = X\otimes X \ket{00}$.</span></span>
<span data-ttu-id="8dd0e-234">Misurando $Z _0 $ e $Z _1 $ individualmente, si ottengono i risultati $r _0 = $1 e $r _1 = $1.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-234">Measuring $Z_0$ and $Z_1$ each individually, we get the results $r_0 = 1$ and $r_1 = 1$.</span></span>
<span data-ttu-id="8dd0e-235">Misurando $Z _0 Z_1 $, tuttavia, viene ottenuto il risultato singolo $r _ {\textrm{joint}} = $0, che indica che la combinazione di $ \ket {11} $ è positiva.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-235">Measuring $Z_0 Z_1$, however, we get the single result $r_{\textrm{joint}} = 0$, representing that the pairity of $\ket{11}$ is positive.</span></span>
<span data-ttu-id="8dd0e-236">Inserisci in modo diverso, $ (-1) ^ {r_0 + r_1} = (-1) ^ r_ {\textrm{joint}}) $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-236">Put differently, $(-1)^{r_0 + r_1} = (-1)^r_{\textrm{joint}})$.</span></span>
<span data-ttu-id="8dd0e-237">In modo critico, poiché si apprende *solo* la parità da questa misurazione, vengono mantenute tutte le informazioni sui quantum rappresentate nella superposizione tra gli stati 2 2-qubit della parità positiva, $ \ket {00} $ e $ \ket {11} $.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-237">Critically, since we *only* learn the parity from this measurement, any quantum information represented in the superposition between the two two-qubit states of positive parity, $\ket{00}$ and $\ket{11}$, is preserved.</span></span>
<span data-ttu-id="8dd0e-238">Questa proprietà sarà essenziale in un secondo momento, perché viene discussa la correzione degli errori.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-238">This property will be essential later, as we discuss error correction.</span></span>

<span data-ttu-id="8dd0e-239">Per praticità, il preludio fornisce anche altre due operazioni per la misurazione di qubits.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-239">For convenience, the prelude also provides two other operations for measuring qubits.</span></span>
<span data-ttu-id="8dd0e-240">Innanzitutto, poiché l'esecuzione di misurazioni qubit è piuttosto comune, il preludio definisce una sintassi abbreviata per questo caso.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-240">First, since performing single-qubit measurements is quite common, the prelude defines a shorthand for this case.</span></span>
<span data-ttu-id="8dd0e-241">L' <xref:Microsoft.Quantum.Intrinsic.M> operazione misura l'operatore Pauli $Z $ in un singolo qubit e ha la firma `(Qubit => Result)` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-241">The <xref:Microsoft.Quantum.Intrinsic.M> operation measures the Pauli $Z$ operator on a single qubit, and has signature `(Qubit => Result)`.</span></span>
<span data-ttu-id="8dd0e-242">`M(q)` equivale a: `Measure([PauliZ], [q])`.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-242">`M(q)` is equivalent to `Measure([PauliZ], [q])`.</span></span>

<span data-ttu-id="8dd0e-243"><xref:microsoft.quantum.measurement.MultiM>Misura l'operatore Pauli $Z $ *separatamente* in ogni matrice di qubits, restituendo la *matrice* di `Result` valori ottenuti per ogni qubit.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-243">The <xref:microsoft.quantum.measurement.MultiM> measures the Pauli $Z$ operator *separately* on each of an array of qubits, returning the *array* of `Result` values obtained for each qubit.</span></span>
<span data-ttu-id="8dd0e-244">In alcuni casi può essere ottimizzato.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-244">In some cases this can be optimized.</span></span> <span data-ttu-id="8dd0e-245">Dispone della firma ( `Qubit[] => Result[])` .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-245">It has signature (`Qubit[] => Result[])`.</span></span>
<span data-ttu-id="8dd0e-246">`MultiM(qs)` equivale a:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-246">`MultiM(qs)` is equivalent to:</span></span>

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a><span data-ttu-id="8dd0e-247">Funzioni di estensione e operazioni</span><span class="sxs-lookup"><span data-stu-id="8dd0e-247">Extension Functions and Operations</span></span> ##

<span data-ttu-id="8dd0e-248">Inoltre, il preludio definisce un set completo di funzioni matematiche e di conversione dei tipi a livello di .NET da usare all'interno del :::no-loc(Q#)::: codice.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-248">In addition, the prelude defines a rich set of mathematical and type conversion functions at the .NET level for use within :::no-loc(Q#)::: code.</span></span>
<span data-ttu-id="8dd0e-249">Ad esempio, lo <xref:Microsoft.Quantum.Math> spazio dei nomi definisce operazioni utili, ad esempio <xref:Microsoft.Quantum.Math.Sin> e <xref:Microsoft.Quantum.Math.Log> .</span><span class="sxs-lookup"><span data-stu-id="8dd0e-249">For instance, the <xref:Microsoft.Quantum.Math> namespace defines useful operations such as <xref:Microsoft.Quantum.Math.Sin> and <xref:Microsoft.Quantum.Math.Log>.</span></span>
<span data-ttu-id="8dd0e-250">L'implementazione fornita da Quantum Development Kit usa la classica libreria di classi base .NET e pertanto può comportare una comunicazione aggiuntiva round trip tra i programmi Quantum e i driver classici.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-250">The implementation provided by the Quantum Development Kit uses the classical .NET base class library, and thus may involve an additional communications round trip between quantum programs and their classical drivers.</span></span>
<span data-ttu-id="8dd0e-251">Sebbene non sia presente un problema per un simulatore locale, può trattarsi di un problema di prestazioni quando si usa un simulatore remoto o un hardware effettivo come computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-251">While this does not present a problem for a local simulator, this can be a performance issue when using a remote simulator or actual hardware as a target machine.</span></span>
<span data-ttu-id="8dd0e-252">Ciò premesso, è possibile che un singolo computer di destinazione rilevi questo effetto, eseguendo l'override di queste operazioni con versioni più efficienti per quel particolare sistema.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-252">That said, an individual target machine may mitigate this performance impact by overriding these operations with versions that are more efficient for that particular system.</span></span>

### <a name="math"></a><span data-ttu-id="8dd0e-253">Math</span><span class="sxs-lookup"><span data-stu-id="8dd0e-253">Math</span></span> ###

<span data-ttu-id="8dd0e-254">Lo <xref:Microsoft.Quantum.Math> spazio dei nomi fornisce molte funzioni utili della [ `System.Math` classe](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1&preserve-view=true)della libreria di classi base .NET.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-254">The <xref:Microsoft.Quantum.Math> namespace provides many useful functions from the .NET base class library's [`System.Math` class](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1&preserve-view=true).</span></span>
<span data-ttu-id="8dd0e-255">Queste funzioni possono essere utilizzate allo stesso modo di qualsiasi altra :::no-loc(Q#)::: funzione:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-255">These functions can be used in the same manner as any other :::no-loc(Q#)::: functions:</span></span>

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

<span data-ttu-id="8dd0e-256">Se un metodo statico .NET è stato sottoposto a overload in base al tipo degli argomenti, la :::no-loc(Q#)::: funzione corrispondente viene annotata con un suffisso che indica il tipo di input:</span><span class="sxs-lookup"><span data-stu-id="8dd0e-256">Where a .NET static method has been overloaded based on the type of its arguments, the corresponding :::no-loc(Q#)::: function is annotated with a suffix indicating the type of its input:</span></span>

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a><span data-ttu-id="8dd0e-257">Operazioni bit per bit</span><span class="sxs-lookup"><span data-stu-id="8dd0e-257">Bitwise Operations</span></span> ###

<span data-ttu-id="8dd0e-258">Infine, lo <xref:Microsoft.Quantum.Bitwise> spazio dei nomi fornisce diverse funzioni utili per la modifica di numeri interi tramite operatori bit per bit.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-258">Finally, the <xref:Microsoft.Quantum.Bitwise> namespace provides several useful functions for manipulating integers through bitwise operators.</span></span>
<span data-ttu-id="8dd0e-259">Ad esempio, <xref:Microsoft.Quantum.Bitwise.Parity> restituisce la parità bit per bit di un Integer come un altro numero intero.</span><span class="sxs-lookup"><span data-stu-id="8dd0e-259">For instance, <xref:Microsoft.Quantum.Bitwise.Parity> returns the bitwise parity of an integer as another integer.</span></span>
