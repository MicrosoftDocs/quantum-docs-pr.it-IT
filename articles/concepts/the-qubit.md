---
title: Qubit in quantum computing
description: Scopri di più su qubits, l'unità di base di informazioni in quantum computing.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
ms.openlocfilehash: 833c9649b7fbcf8b9fde62c37246b9345fe59a92
ms.sourcegitcommit: e23178d32b316d05784a02ba3cd6166dad177e89
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/09/2020
ms.locfileid: "84630350"
---
# <a name="the-qubit"></a><span data-ttu-id="5f1c0-103">Qubit</span><span class="sxs-lookup"><span data-stu-id="5f1c0-103">The Qubit</span></span>

<span data-ttu-id="5f1c0-104">Proprio come bits sono l'oggetto fondamentale delle informazioni nell'elaborazione classica, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (Quantum BITS) sono l'oggetto fondamentale delle informazioni in quantum computing.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="5f1c0-105">Per comprendere questa corrispondenza, esaminiamo l'esempio più semplice: un singolo qubit.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="5f1c0-106">Rappresentazione di un qubit</span><span class="sxs-lookup"><span data-stu-id="5f1c0-106">Representing a Qubit</span></span>

<span data-ttu-id="5f1c0-107">Mentre un bit, o una cifra binaria, può avere valore $0 $ o $1 $ , un qubit può avere un valore che corrisponde a uno di questi o a una superposizione quantistica di $0 $ e $1 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="5f1c0-108">Lo stato di un singolo qubit può essere descritto da un vettore di colonna bidimensionale di unità Norm, ovvero la grandezza quadrata delle relative voci deve essere sommata a $1 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="5f1c0-109">Questo vettore, denominato quantum state Vector, include tutte le informazioni necessarie per descrivere il sistema Quantum One-qubit, proprio come un singolo bit, che include tutte le informazioni necessarie per descrivere lo stato di una variabile binaria.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="5f1c0-110">Qualsiasi vettore di colonna bidimensionale di numeri reali o complessi con norma $1 $ rappresenta un possibile stato quantum utilizzato da un qubit.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="5f1c0-111">Quindi $ \begin{ bmatrix } \Alpha \\ \\ \beta \end{ bmatrix } $ rappresenta uno stato di qubit se $ \Alpha $ e $ \beta $ sono numeri complessi che soddisfano $ | \Alpha | ^ 2 + | \beta | ^ 2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="5f1c0-112">Alcuni esempi di vettori di stato quantum validi che rappresentano qubits includono</span><span class="sxs-lookup"><span data-stu-id="5f1c0-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="5f1c0-113">$ $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{1 } {\sqrt{2 } } \end{ bmatrix } , \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac { -1 } {\sqrt{2 } } \end{ bmatrix } , \Text { e} \begin{ bmatrix } \frac{1 } {\sqrt{2} \frac{i {\sqrt{2} \end{ } \\ \\ } } bmatrix } . $ $</span><span class="sxs-lookup"><span data-stu-id="5f1c0-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="5f1c0-114">I vettori di stato quantum $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ e $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $ accettano un ruolo speciale.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="5f1c0-115">Questi due vettori formano una base per lo spazio vettoriale che descrive lo stato di qubit.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="5f1c0-116">Ciò significa che qualsiasi vettore di stato quantum può essere scritto come una somma di questi vettori di base.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="5f1c0-117">In particolare, Vector $ \begin{ bmatrix } x \\ \\ y \end{ bmatrix } $ può essere scritto come $x \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } + y \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="5f1c0-118">Sebbene la rotazione di questi vettori possa essere usata come base perfettamente valida per qubit, si sceglie di privilegiare questo valore, chiamandolo come *base computazionale*.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="5f1c0-119">Questi due stati Quantum corrispondono ai due stati di un bit classico, ovvero $0 $ e $1 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="5f1c0-120">La convenzione standard consiste nel scegliere</span><span class="sxs-lookup"><span data-stu-id="5f1c0-120">The standard convention is to choose</span></span>

<span data-ttu-id="5f1c0-121">$ $0 \equiv \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \qquad 1 \equiv \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , $ $</span><span class="sxs-lookup"><span data-stu-id="5f1c0-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="5f1c0-122">Sebbene la scelta opposta possa essere eseguita ugualmente correttamente.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="5f1c0-123">Pertanto, dal numero infinito di possibili vettori di stato quantum a singolo qubit, solo due corrispondono agli Stati dei bit classici; tutti gli altri Stati quantum non lo sono.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="5f1c0-124">Misurazione di un qubit</span><span class="sxs-lookup"><span data-stu-id="5f1c0-124">Measuring a Qubit</span></span>

<span data-ttu-id="5f1c0-125">Ora che si è appreso come rappresentare una qubit, è possibile ottenere alcune informazioni sull'aspetto di questi stati esaminando il concetto di [*misurazione*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span><span class="sxs-lookup"><span data-stu-id="5f1c0-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="5f1c0-126">Una misura corrisponde all'idea informale di "ricerca" in un qubit, che comprime immediatamente lo stato del quantum in uno dei due stati classici $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ o $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="5f1c0-127">Quando si misura un qubit fornito da quantum state Vector $ \begin{ bmatrix } \Alpha \\ \\ \beta \end{ bmatrix } $, viene ottenuto il risultato $0 $ con la probabilità $ | \Alpha | ^ 2 $ e il risultato $1 $ con la probabilità $ | \beta | ^ 2 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="5f1c0-128">Nel risultato $0 $ , il nuovo stato di qubit è $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $; nel risultato $1 $ il suo stato è $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="5f1c0-129">Si noti che queste probabilità riassumono fino a $1 a $ causa della condizione di normalizzazione $ | \Alpha | ^ 2 + | \beta | ^ 2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="5f1c0-130">Le proprietà di misurazione indicano anche che il segno generale del vettore di stato quantum è irrilevante.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="5f1c0-131">La negazione di un vettore equivale a $ \Alpha \rightarrow-\Alpha $ e $ \beta \rightarrow-\beta $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="5f1c0-132">Poiché la probabilità di misurare $0 $ e $1 $ dipende dalla grandezza quadrata dei termini, l'inserimento di tali segni non comporta alcuna modifica delle probabilità.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="5f1c0-133">Tali fasi sono comunemente chiamate [ \`\` *fasi globali*''](https://en.wikipedia.org/wiki/Phase_factor) e più in generale possono essere nel formato $e ^ {i \Phi } $ anziché solo $ \pm 1 $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="5f1c0-134">Una delle principali proprietà importanti della misurazione è che non danneggia necessariamente tutti i vettori di stato quantistici.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="5f1c0-135">Se si inizia con un qubit nello stato $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $, che corrisponde allo stato classico $0, la $ misurazione di questo stato produrrà sempre il risultato $0 $ e rimarrà invariato lo stato del quantum.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="5f1c0-136">In questo senso, se sono presenti solo bit classici (ad esempio, qubits $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ o $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $), la misurazione non danneggia il sistema.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="5f1c0-137">Ciò significa che è possibile replicare i dati classici e manipolarli in un computer Quantum come un computer classico.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="5f1c0-138">La possibilità, tuttavia, di archiviare le informazioni in entrambi gli stati in una sola volta è quello che eleva il calcolo quantistico oltre quello che è possibile in modo classico e deruba ulteriormente i computer Quantum della possibilità di copiare i dati Quantum in modo indiscriminato, vedere anche [il teorema di no-cloning](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="5f1c0-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="5f1c0-139">Visualizzazione di qubits e trasformazioni con la sfera Bloch</span><span class="sxs-lookup"><span data-stu-id="5f1c0-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="5f1c0-140">Qubits può anche essere illustrato in $3 $ D usando la rappresentazione della [*sfera Bloch*](https://en.wikipedia.org/wiki/Bloch_sphere) .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="5f1c0-141">La sfera Bloch fornisce un modo per descrivere uno stato del quantum a qubit singolo (ovvero un vettore complesso bidimensionale) come vettore con valori reali tridimensionali.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="5f1c0-142">Questo è importante perché consente di visualizzare gli Stati qubit singoli e di sviluppare ragionamenti che possono risultare utili per comprendere gli Stati qubit, dove Sfortunatamente la rappresentazione della sfera Bloch si interrompe.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="5f1c0-143">La sfera Bloch può essere visualizzata come segue:</span><span class="sxs-lookup"><span data-stu-id="5f1c0-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="5f1c0-144">![Sfera Bloch](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="5f1c0-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="5f1c0-145">Le frecce in questo diagramma mostrano la direzione in cui il vettore di stato quantum sta puntando e ogni trasformazione della freccia può essere considerata come una rotazione di uno degli assi cardinali.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="5f1c0-146">Quando si pensa a un calcolo quantistico come una sequenza di rotazioni è un'intuizione avanzata, è difficile usare questa intuizione per la progettazione e la descrizione degli algoritmi.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="5f1c0-147">Q # attenua questo problema fornendo un linguaggio per la descrizione di tali rotazioni.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="5f1c0-148">Operazioni Single-qubit</span><span class="sxs-lookup"><span data-stu-id="5f1c0-148">Single-Qubit Operations</span></span>

<span data-ttu-id="5f1c0-149">I computer Quantum elaborano i dati applicando un set universale di controlli Quantum che possono emulare qualsiasi rotazione del vettore di stato quantum.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="5f1c0-150">Questa nozione di universalità è simile alla nozione di universalità per il calcolo tradizionale (ovvero classica) in cui un set di controllo è considerato universale se ogni trasformazione dei bit di input può essere eseguita usando un circuito di lunghezza finita.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="5f1c0-151">In quantum computing, le trasformazioni valide che è possibile eseguire su un qubit sono le trasformazioni e la misurazione unitarie.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="5f1c0-152">L' *operazione contigua* o la trasposta del coniugato complesso è di importanza fondamentale per l'elaborazione quantistica perché è necessaria per invertire le trasformazioni Quantum.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="5f1c0-153">Q # riflette questo aspetto fornendo metodi per compilare automaticamente le sequenze di controllo nel rispettivo contiguo, che consente di evitare che il programmatore debba consegnare i contigui al codice in molti casi.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="5f1c0-154">Un esempio è illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="5f1c0-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="5f1c0-155">Sebbene si tratta di un esempio banale (poiché l' <xref:microsoft.quantum.intrinsic.h> operazione è autocontigua), è possibile vedere come questa operazione diventa inestimabile per operazioni qubit più complesse.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="5f1c0-156">Per ulteriori informazioni, vedere [operazioni e funzioni](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="5f1c0-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="5f1c0-157">Sono disponibili solo quattro funzioni che eseguono il mapping di un bit a un bit in un computer classico.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="5f1c0-158">Al contrario, è presente un numero infinito di trasformazioni unitarie in un singolo qubit in un computer Quantum.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="5f1c0-159">Pertanto, nessun set limitato di operazioni Quantum primitive, denominate [*Gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), può replicare esattamente il set infinito di trasformazioni unitarie consentite in quantum computing.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="5f1c0-160">Ciò significa che, a differenza dell'elaborazione classica, è impossibile per un computer Quantum implementare ogni possibile programma Quantum usando esattamente un numero finito di attività di controllo.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="5f1c0-161">Di conseguenza, i computer quantum non possono essere universali nello stesso senso dei computer classici.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="5f1c0-162">Di conseguenza, quando si afferma che un set di controlli è *universale* per quantum computing, significa che si tratta di un elemento leggermente più debole rispetto al calcolo classico.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="5f1c0-163">Per quanto riguarda l'universalità, è necessario che un computer Quantum *approssimi* solo ogni matrice unitaria all'interno di un errore finito usando una sequenza di Gate di lunghezza finita.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="5f1c0-164">In altre parole, un set di controlli è un set di porte universali se una qualsiasi trasformazione unitaria può essere scritta approssimativamente come un prodotto di controllo da questo set.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="5f1c0-165">È necessario che per ogni errore previsto associato esistano delle attività di controllo $G _ {1 } , G_ {2 } , \ldots G_N $ dal set di controllo in modo che</span><span class="sxs-lookup"><span data-stu-id="5f1c0-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="5f1c0-166">$ $ G_N G_ {N-1 } \cdots G_2 G_1 \Approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="5f1c0-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="5f1c0-167">Si noti che poiché la convenzione per la moltiplicazione di matrici consiste nel moltiplicare da destra a sinistra la prima operazione di controllo in questa sequenza, $G _N $ , è effettivamente l'ultima applicata al vettore di stato quantum.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="5f1c0-168">Più formalmente, si afferma che tale set di controlli è universale se per ogni tolleranza di errore $ \epsilon>0 esiste $ $G _1, \ldots G_N $ in modo che la distanza tra $G _N \ldots G_1 $ e $U $ sia al massimo $ \epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="5f1c0-169">Idealmente, il valore di $N $ necessario per raggiungere questa distanza di $ \epsilon $ dovrebbe ridimensionare Poly-logaritmicamente con $1/\ Epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="5f1c0-170">Che cos'è un set di controllo universale in pratica?</span><span class="sxs-lookup"><span data-stu-id="5f1c0-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="5f1c0-171">Il set di controllo universale più semplice per le attività di controllo single-qubit è costituito solo da due controlli: il Gate Hadamard $H $ e il cosiddetto $T $ -Gate (noto anche come il Gate $ \ PI/8 $ ):</span><span class="sxs-lookup"><span data-stu-id="5f1c0-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="5f1c0-172">$ $ H = \frac{1 } {\sqrt{2 } } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad T = \begin{ bmatrix } 1 & 0 \\ \\ 0 & e ^ {i \ PI/4 } \end{ bmatrix } .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="5f1c0-173">Tuttavia, per motivi pratici relativi alla correzione degli errori quantistici, può essere più pratico considerare un set di controllo più ampio, ovvero uno che può essere generato usando $H $ e $T $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="5f1c0-174">È possibile classificare i controlli Quantum in due categorie: Clifford Gates e il $T $ -Gate.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="5f1c0-175">Questa suddivisione è utile perché in molti schemi di correzione degli errori quantistici i cosiddetti Clifford Gates sono facili da implementare, ovvero richiedono pochissime risorse in termini di operazioni e qubits per implementare la tolleranza di errore, mentre i cancelli non Clifford sono piuttosto costosi quando richiedono la tolleranza di errore.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="5f1c0-176">Il set standard di single-qubit Clifford Gates, [incluso per impostazione predefinita in Q #](xref:microsoft.quantum.libraries.standard.prelude), include</span><span class="sxs-lookup"><span data-stu-id="5f1c0-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="5f1c0-177">$ $ H = \frac{1 } {\sqrt{2 } } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad S = \begin{ bmatrix } 1 & 0 \\ \\ 0 & i \end{ bmatrix } = T ^ 2, \qquad X = \begin{ bmatrix } 0 &1 \\ \\ 1 & 0 \end{ bmatrix } = HT ^ 4h, $ $</span><span class="sxs-lookup"><span data-stu-id="5f1c0-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="5f1c0-178">$ $ Y = \begin{ bmatrix } 0 &-i \\ \\ & 0 \END{ bmatrix } = t ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{ bmatrix } 1&0 \\\\ 0 & -1 \end{ bmatrix } = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="5f1c0-179">Qui le operazioni $X $ , $Y $ e $Z $ vengono usate con particolare frequenza e sono denominate [*operatori Pauli*](https://en.wikipedia.org/wiki/Pauli_matrices) dopo il creatore Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="5f1c0-180">Insieme al Gate non-Clifford (il $T $ -Gate), queste operazioni possono essere composte per approssimare qualsiasi trasformazione unitaria in un singolo qubit.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="5f1c0-181">Per altre informazioni su queste operazioni, le rappresentazioni della sfera Bloch e le implementazioni di Q #, vedere [operazioni e funzioni intrinseche](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="5f1c0-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="5f1c0-182">Come esempio del modo in cui è possibile compilare le trasformazioni unitarie da queste primitive, le tre trasformazioni illustrate nelle sfere Bloch precedenti corrispondono alla sequenza di controllo $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } \mapsto HZH \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } = \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="5f1c0-183">Sebbene i precedenti costituiscano i controlli primitivi più diffusi per la descrizione delle operazioni sul livello logico dello stack (si pensi al livello logico come livello dell'algoritmo Quantum), è spesso utile considerare meno operazioni di base a livello algoritmico, ad esempio operazioni più vicine a un livello di descrizione della funzione.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="5f1c0-184">Fortunatamente, Q # dispone anche di metodi per l'implementazione di unitaries di livello superiore, che a loro volta consentono di implementare algoritmi di alto livello senza scomporre in modo esplicito tutti gli elementi fino a Clifford e $T $ -Gates.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="5f1c0-185">La primitiva più semplice è il singolo qubit-Rotation.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="5f1c0-186">Vengono in genere considerate tre rotazioni a qubit singolo: $R _x $ , $R _y $ e $R _z $ .</span><span class="sxs-lookup"><span data-stu-id="5f1c0-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="5f1c0-187">Per visualizzare l'azione della rotazione $R _x (\theta) $, ad esempio, si supponga di puntare il pollice destro lungo la direzione dell'asse $x $ della sfera Bloch e ruotare il vettore con la mano in un angolo di $ \ Theta/2 $ radianti.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="5f1c0-188">Questo fattore di confusione di $2 $ deriva dal fatto che i vettori ortogonali sono $180 ^ \circ $ a parte se tracciati nella sfera Bloch, ma sono in realtà $90 ^ \circ $ Degrees, a parte geometrica.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="5f1c0-189">Le matrici unitarie corrispondenti sono:</span><span class="sxs-lookup"><span data-stu-id="5f1c0-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="5f1c0-190">\begin{align *} &R_z (\theta) = e ^ {-i\theta z/2 } = \begin{ bmatrix } e ^ {-i \ Theta/2 } & 0 \\\\ 0 & e ^ {i \ Theta/2 } \end{ bmatrix } , \\ \\ &R_x (\theta) = e ^ {-i\theta x/2 } = HR_z (\theta) H = \begin{ bmatrix } \cos (\ Theta/2) &-i\sin (\ Theta/2) \\ \\ -i\sin (\ Theta/2) & \cos (\ Theta/2) \end{ bmatrix } , \\ \\ &R_y (\theta) = e ^ {-i\theta y/2 } = SHR_z (\theta) HS ^ \dagger = \begin{ bmatrix } \cos (\ Theta/2) &-\sin (\ Theta/2) \\ \\ \sin (\ Theta/2) & \cos (\ Theta/2) \end{ bmatrix } . \end{align*}</span><span class="sxs-lookup"><span data-stu-id="5f1c0-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="5f1c0-191">Così come tutte e tre le rotazioni possono essere combinate insieme per eseguire una rotazione arbitraria in tre dimensioni, è possibile osservare dalla rappresentazione della sfera Bloch che qualsiasi matrice unitaria può essere scritta come una sequenza di tre rotazioni.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="5f1c0-192">In particolare, per ogni matrice unitaria $U esiste $ $ \Alpha, \beta, \gamma, \delta in $ modo che $U = e ^ {i \alpha } R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="5f1c0-193">Pertanto $R _z (\theta) $ e $H $ anche un set di controllo universale, sebbene non sia un set discreto perché $ \theta $ può assumere qualsiasi valore.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="5f1c0-194">Per questo motivo, e a causa delle applicazioni nella simulazione quantistica, le attività di controllo continuo sono cruciali per il calcolo quantistico, soprattutto a livello di progettazione dell'algoritmo Quantum.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="5f1c0-195">Per ottenere un'implementazione hardware a tolleranza di errore, questi ultimi verranno compilati in sequenze di controllo discrete che si avvicinano strettamente a queste rotazioni.</span><span class="sxs-lookup"><span data-stu-id="5f1c0-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
